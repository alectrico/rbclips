%=========================================================================
\chapter{Úvod}
%=========================================================================
TODO: Dopsat zvnaneni proc jsme se rozhodli napsat tento wrapper, popsat jednotlive kapitoly

%=========================================================================
\chapter{Pou¾ité technologie}
%=========================================================================

\section{Ruby}
Ruby\cite{webRuby} je relativnì nový dynamický skriptovací jazyk vytvoøený japonským in¾enýrem jménem Yukihiro Matsumoto známym pod pøezdívkou Matz (pou¾ito dále v textu). V souèasné dobì neexistuje ¾ádná specifikace èi norma jako je tomu napøíklad u jazykù C/C++ a dal¹ích. Z tohoto dùvodu se jako reference jazyka bere samotný interpret napsaný Matzem - MRI (Mat'z ruby intepreter). Interpretù existuje více a jejich zkrácený seznam je uveden dále v textu. Absence existujícího standartu vedla v roce 2008 k vytvoøení skupiny pro standardizaci tohoto jazyka v rámci japonské organizace IPA (Information-technology Promotion Agency), která vychází z MRI verze 1.8.7. V souèasné dobì je k dispozici ji¾ návrh standartdu\cite{webRubySpec}, který má být navr¾en ke schválení prvnì v japonsku u Japanese Industrial Standards Committee (JISC) a následnì i u mezinárodní organizace ISO.

\subsection{Historie}
První verze interpretu ruby vytvoøená Matzem byla zveøejnìna u¾ v roce 1995 (velice zajimavý je fakt, ¾e jméno nového jazyka u¾ bylo vybráno v roce 1993, tedy o cele dva roky døíve), ov¹em oficální webové stránky jazyka (interpretu) v angliètinì byly k dispozici a¾ o tøi roky pozdìji - tedy v roce 1998. Absence kvalitních materiálù v angliètinì je jedním z hlavních dùvodù, proè se ruby stal populárním prvnì pouze v japonsku a velice pomalu se dostával i do ostatních státu svìta. V dne¹ní dobì u¾ na¹tìstí není problém najít kvalitní zdroje informací ani v angliètinì ani v èe¹tinì (èi dál¹ích jazycích) a to jak ve webové tak i v kni¾ní podobì.

Matz vytvoøil nový jazyk\cite{webMatzInterview}, proto¾e ho nadchly mo¾nosti skriptovacích jazyku a ¾adný z tehdy dostupných jazykù ho nezaujal - chtìl jazyk mocnìj¹í ne¾ perl a více objektì orientovaný ne¾ python.  Na otázku, proè vytvoøil dal¹í skriptovací jazyk, Matz je¹tì èasto dodává dùvody syntaxe - programovacích jazyku je mnoho a jsou svým zpùsobem velice podobné co se do mo¾ností týèe. Matz chtìl jazyk, ve kterém ho bude bavit psát a nebude se muset pøíli¹ trápit se zápisem jednotlivých konstrukcí (syntaxe by mìla být podøízena èlovìku jako¾to pisateli jazyka, nikoliv opaènì poèítaèi jako¾to interpretu jazyka).

Nìkolik zajímavých dat z historie\cite{webRubyHistory}:
\begin{description}
 \item[1993] Vybráno jméno
 \item[1995] První zveøejnìná verze interpretu (verze 0.95)
 \item[1996] Verze 1.0
 \item[1997] Matz zamìstnán jako full-time ruby programátor (tedy jako programátor v jazyce, který si sam vytvoøil)
 \item[1998] Webové stránky v angliètinì a vznik anglicky psaného mailing listu 
 \item[1999] První kniha o ruby (psána japonsky)
 \item[2000] Zaèátek roz¹iøování povìdomí o ruby mimo hranice Japonska
 \item[2001] YARPC - Yet Another Ruby and Perl Conference
 \end{description}

V souèasné verze se udr¾ují dvì hlavní vìtve MRI - verze 1.8 a 1.9. Vìtev 1.8 je pova¾ována za stabilní a ji¾ se pouze udr¾uje (opravují se chyby), vývoj probíhá ve vìtvi 1.9.

\subsection{Vlastnosti ruby}
Ruby je dynamický skriptovací jazyk mnoha ruzných paradigmat - je plnì objektovì orientovaný, ale lze v nìm bez problémù psát i imperativnì èi funkcionálnì. Následuje popis vybraných vlastností, které bych rád vyzdvihl èi na nì upozornil. Podle poøeby budu dále v textu srovnávat Ruby s dal¹ímy jazyky které znám - Java, C/C++, python a perl.

Ní¾e uvedený popis vlastní jsem èerpal ze své osobní zku¹enosti s tímto programovacím jazykem, z velice obsáhleho popisu jazyka napsaného samotným autorem ruby The Ruby programming language\cite{rubyProgrammingLanguage} (co¾ je zrevidování a roz¹íøení døíve vydané knihy, která je v ruby svìtì známa pod názvem Ruby in Nutshel\cite{rubyInNutshel}) a z knihy Metaprogramming Ruby\cite{metaprogrammingRuby}, která se zabývá nejen metaprogramováním v ruby, ale take velice èitelným zpùsobem vysvìtluje objektový model ruby a jeho jiné aspekty.

\subsubsection{Objektovost}
Ruby je plnì objektovì orientovaný jazyk (byl mimo jiné inspirován i Smalltalkem), co¾ znamená, ¾e v¹e v ruby je objekt. Nejsou zde ¾ádná datová primitiva jako napøíklad v Jave (int, double). \u{C}íselné a jiné konstanty jsou interpretem pøevádìny na instance pøíslu¹ných tøíd okam¾ite a automaticky:

\begin{verbatim}
 123.class # => Fixnum
\end{verbatim}

Konstanta 123 je lexikálním analyzátorem pøevedena na objekt pøíslu¹ného typu (zde instance tøídy Fixnum), na který okam¾itì mohu volat metodu (v pøíkladì volám metodu pro zji¹tìní tøídy ke které objekt nále¾í).

Interpret ruby po svém startu vytvoøí bezejmenou instanci tøídy Object a v jejím kontextu poté vykonává pøedaný skript. Není zde tedy nutnost vytváøet tøídu a jednu veøejnou metodu, která se spustí po startu aplikace jako je tomu napøíklád v Jave èi funkci main() jako u C++. Ukázkový ``Hello world!'' program, který v ruby vypadá takto: \verb|puts "Hello world!"|, je tedy objektový k\'{o}d, i kdy¾ se tak na první pohled nezdá - toto lze dokazát vypsaním tøídy aktualního objektu \verb|puts self.class|, která vratí ``Object'' i kdy¾ pro pisatele v ¾ádném objektu není (\verb|self| je obdoba ukazatele \verb|this| z jazyka C++, tedy ``ukazatel'' na aktuální objekt),

Dal¹í a pro mì v dobì, kdy jsem s ruby poprvé seznamoval, velice pøekvapivý dùsledek plné objektovosti je fakt, ¾e tøídy samy jsou objekty. Tuto skuteènost jsem ji¾ vysvìtloval mnoha lidem a èasto jsem byl nepochopen, proto toto tvrzení rozvedu tro¹ku více. Objekt (instance) je neformálnì øeèeno mno¾ina promìných daného objektu a mno¾ina method, které na nìm lze volat (z formálnìj¹íh hlediska mno¾ina zpráv, kterým objekt rozumí). Ka¾dy objekt patøí nìjaké tøídì - tøída tedy urèitým zpùsobem popisuje mno¾inu objektù (napøíklad seznam zpráv/metod, kterým v¹echny objekty dané tøídy rozumí). Pro lep¹í vysvìtlení mohu øíci, ¾e promìné existují v objektu (pro ka¾dý objekt mohou být jiné nebo nabývat jiných hodnot) a metody existují ve tøídì (proto¾e jsou sdílené mezi v¹emi objekty této tøídy). 
\begin{figure}[ht]
  \centering
  \includegraphics[width=8cm,keepaspectratio]{fig/fig-ruby-inst_obj.png}
  \caption{Promìné, metody a jejich umístìní v instancích a tøídách}
  \label{fig_ruby_inst_obj}
\end{figure}

Tøídy jsou v ruby také objekty (instance jiné tøídy - konkrétnì tøídy Class) - mají tedy své instanèní promìné a lze na nich volat metody (které jsou umístìny v tøídì dané tøídy).

\begin{figure}[ht]
  \centering
  \includegraphics[width=12cm,keepaspectratio]{fig/fig-ruby-inst_obj_2.png}
  \caption{Tøída je také objekt}
  \label{fig_ruby_inst_obj_2}
\end{figure}

Z urèitého hlediska se na tuto vlastnost lze koukat jako na statické promìné a metody u jazyku C++, i kdy¾ bych u toho pøirovnání byl opatrný. Praktické vyu¾ítí této vlastnosti zmíním v odstavci o dynamiènosti ruby.

\subsubsection{Volná syntaxe}
Matz chtìl od zaèátku vytvoøit jazyk, ve ktém by ho bavilo programovat\cite{webMatzInterview} - ve kterém by nemusel poøád pøemý¹let na syntaxí, který by byl krásnì èitelný a hlavnì pokud mo¾no co nejbli¾¹í bì¾nému lidskému jazyku. Ukázky k\'{o}du pøi ètení opravdu pøipomínájí anglické vìty, popisující co se vlastnì má dìlat:

\begin{description}
 \item \verb|3.times do puts 'Ahoj'| 3x vypi¹ ``Ahoj''
 \item \verb|puts "Ahoj" if name == "jarcec"| Vypi¹ ahoj pokud se jmenuju jarcec
\end{description}

Závorky oddìlující název metody od jejich parametrù jsou v místech kde to není syntakticky nejednoznaèné volitelné, mohu tedy zavolat metodu \verb|naDruhou| s parametrem 5 tak jak je zvykem v Javì/C/C++ \verb|naDruhou(5)| nebo na mnoha místech více èitelnìji \verb|naDruhou 5|. Volání metod bez závorek vypadá na mnoha místech jako klíèové slovo, které deklaruje spí¹e ne¾ volání metody - na první pohled se mù¾e jevit spí¹e jako matoucí, ale uvedu pøíklad z webového frameworku Ruby on Rails (dále v textu RoR):

\begin{verbatim}
class Human < ActiveRecord::Base
  has_many     :articles
  belongs_to   :department
end
\end{verbatim} 

I èlovìk bez znalosti ruby nebo RoR, ale se znalostí jiných programovacích jazykù, je schopen s velkou úspì¹ností odhadnout, ¾e prezentovaný pøíklad vytváøí tøídu Human, s nìjakým typem závislosti na oddìlení (department) a který napsal mnoho rùzných èlánkù (articles). Tento spí¹e sociální efekt (``Jedná se o metodu nebo klíèové slovo?'') jde velice hluboko - mnohdy lze u¾ úvodních tutoriálech k Ruby najít zmínku o klíèovém slovu \verb|puts|, slou¾ícím pro výpis na standartní výstup (obdoba \verb|printf()| z C, \verb|echo| z bashe nebo \verb|print| z perlu). Ve skuteènosti se ov¹em nejedná o klíèové slovo, ale o metodu modulu Kernel, který ka¾dy objekt dìdí a proto je na ka¾dém místì programu dostupná - jedná se tedy plnohodnotnou metodu a jde stejnì jako jakákoliv jíná v pøípade potøeby pøetí¾it nebo z objektu odstranit...

Odstranìní nutnosti v¹ude psát závorky beru jako velice kladnou vlastnost, kterou velice èasto a rád vyu¾ívám, na druhou stranu ov¹em musím upozornit na její dopady - i pouhá mezera mù¾e zmìnit logiku kódu s jakou bude zpracován:

\begin{verbatim*}
puts naDruhou(1+2)*2
puts naDruhou (1+2)*2
\end{verbatim*}
 
Oba pøíklady se li¹í pouhou mezerou mezi koncem názvu metody a otevírající závorkou. V prvním pøípadì syntaktický analyzátor najde ihned za názvem metody závorku a tak ví, ¾e uvnitø jsou parametry se kterými se poté metoda zavolá a následnì vrácená hodnota se vynasobí dvìmi. Výsledek bude tedy $18$ (=$3^2  * 2$). V druhém pøíkladì syntaktický analyzátor najde za názvem metody mezeru a tedy ví, ¾e následuje seznam argumentù oddìlený èárkami (závorky okolo argumentù jsou vynechány). Na øádce se ¾ádná èárka nenachazí a tedy celý výraz $(1+2)*2$ je metodì pøedán jako argument s výsledkem $36$ (=$((1+2) * 2)^2$)!

Ruby neumo¾nuje pojmenovat argumenty metody jako je mo¾né napøíklad v pythonu, ov¹em volná syntaxe pro vytvoøení hashe (asociativního pole) je hojnì vyu¾ívaná k napodobení této schopnosti - pøíkladem mù¾e být tøeba volání fiktivní metody pro hledání: \verb|find :name => 'Jarek', :surname => 'Cecho'|, kde opticky pøedávám dva parametry - name, surname. Ve skuteènosti je tento zápis reprezentován jako tvorba asociativního pole s klièi name a surname (s pøíslu¹nými hodnotami) a¾ naslednì toto pole je jako jeden argument pøedáno metodì \verb|find|. Webový framework Ruby on Rails tento pøístup pou¾ívá snad úplnì v¹ude.

\subsubsection{Dynamiènost a otevøenost}
Dynamiènost je velmi obsáhle slovo, zde je my¹leno jako jazyk provádìjící mnoho èinností a¾ za bìhu programu ne¾ pøi jeho pøekladu (èi v pøípadì skriptovacího jazyka zpracovávání). Vzhledem k plné objektovosti nemá moc smysl mluvit o typovosti jazyka (v¹e je objekt a ty mezi sebou komunikují pomocí zasílání zpráv).

Mnohem zajimavìj¹í a ne a¾ tak bì¾nou vlastní je otevøenost ruby. Ka¾dý objekt mù¾e být za bìhu otevøen a roz¹íøen o nové metody podobnì jako JavaScript. \u{C}asto se toho vyu¾ívá u tøíd (napøíklad roz¹íøením vìstavìné tøídy o nové metody). Tuto vlastnost by do urèité míry ¹lo nahradit dìdièností (nové metody ulo¾it do potomka), ale jen pokud se bavíme o tøídách. Jak jsem uvedl vý¹e, v¹e v ruby je objekt (tedy i tøídy), tak¾e roz¹íøit jdou nejen tøídy, ale i instance jednotlivých tøíd, co¾ byl pro mì jako¾to programátora v C++ docela ¹ok pøi seznamování se s tímto jazykem. Mo¾nosti roz¹íøení instancí o nové metody pou¾ívám i v rbClips, co¾ je popsáno ní¾e v kapitole o Faktech. 

\begin{verbatim}
class A
  def metodaA
    4
  end
end

a = A.new
a.metodaA # => 4

b = A.new
def b.metodaB
  5
end
b.metodaB # => 5
a.metodaB # => Exception NoMethodError
\end{verbatim}
Uvedený pøíklad schopnost roz¹íøit instance objektù ukazuje v praxi.

Díky dynamiènosti a otevøenosti se v ruby velice pìknì metaprogramuje (co¾ je dál¹í mnohoznaèný výráz - zde ve významu psaní k\'{o}du, který generuje dal¹í k\'{o}d). Jedná se o velice èasto vyu¾ívanou schopnost jazyka a velké projekty v ruby jsou metaprogramováním dosti ovlivnìny. Pøíkladem mù¾e být projekt ActiveRecords, který zapouzdøuje èinnost s relaèními databázemi tak, aby se u¾ivatel se SQL vùbec nesetkal (v¹e má krásnì naservírované v objektech):

\begin{verbatim}
class Human < ActiveRecords::Base
end

jarcec = Human.new
jarcec.name = "Jarek"
jarcec.surname = "Cecho"
jarcec.save
\end{verbatim}

V definici tøídy chybí deklarace method \verb|name| a \verb|surname| a pøesto daný k\'{o}d bude fungovat. Konstruktor tøídy se toti¾ pøi inicializaci podívá do databáze na strukturu tabulky kterou popisuje, v tomto pøípadì tabulky \verb|humans| (popis ActiveRecords a jejich jmenných konvencí jsou nad rámec této práce, v¹e lze najít v oficiální dokumentaci\cite{webActiveRecord}, pìkné vysvìtlení je v guides k RoR\cite{webRubyGuides} a taky v nìkolika kapitolách Metaprogramming Ruby\cite{metaprogrammingRuby}) a vytvoøí ke v¹em nalezeným sloupcùm pøíslu¹né metody (jak pro ètení, tak pro zápis). Tento pøístup usnad\u{n}uje údr¾bu k\'{o}du - v definice tøídy není seznam sloupcù jednotlivých tabulek a proto pøi zmìnì databázového schéma není nutné v¹e upravovat a zvedat tak pravdìpodobnost zavleèení chyby (nekonzistence seznamu sloupcù v databázi a v definici tøídy).

O metaprogramování v ruby byla napsána velice pìkná kniha - Metaprogrammin Ruby\cite{metaprogrammingRuby} - psaná spí¹e laickým stylem a na praktických pøíkladech popisující co pøesnì se pod pojmem metapogramovaní skrývá a jak toho v ruby co nejefektivnìji vyu¾ít.

\subsubsection{Bloky}
Blok je podobnì jako v C/C++ nebo Jave mno¾ina pøíkazù ohranièená slo¾enymí závorkami (nebo v pøípadì ruby je je¹tì mo¾né blok ohranièit klíèovými slovy \verb|do| a \verb|end|). Na rozdíl od zmínìných jazykù v ruby jde s bloky dìlat o dost vìt¹í kouzla a proto je zmi\v{n}uji v samostatné kapitole. Jako první dùle¾itý rozdíl je mo¾nost pøedat bloku parametry (a ten se pak vlastnì chová jako taková malá bezejmená funkce). Druhý velice dùle¾itý rozdíl je schopnost bloky v ruby pøedávát do method. Pøíkladem mù¾e být zámìna velikosti písmen v poli øetezcù:

\begin{verbatim}
["AHOJ", "NAZDAR", "HI"].map{|prvek| prvek.downcase}
    # => ["ahoj", "nazdar", "hi"]
\end{verbatim}

\verb|map| je metoda tøídy pole, která pøijímá blok akceptující jeden parametr a pro ka¾dý prvek v poli tento blok zavolá. Návratovou hodnotu bloku (v ruby je v¹e výraz a tak i bloky vracejí své hodnoty, ale tato vlastnost je popsána ní¾e) ulo¾í do pole na místo volaného prvku. Ukázka tedy zmen¹í velikost písmen pro kazdý prvek v poli.

S bloky se pojí jeden dùle¾íty pojem - uzávìr (anglicky closure). Ka¾dý blok si s sebou nese vazby na lokální promìné známe v dobì jeho vzniku (anglicky bindings). Osvìtlující pøíklad:

\begin{verbatim}
def foo
  a = 10
  yield # Zavolej predany blok
end

a = 30
foo { puts a } # Vytiskne hodnotu promene a, ale ktere? 10 nebo 30?
\end{verbatim} 

Blok si ``pamatuje`` svou lokální promìnou \verb|a| (s hodnotou 30) a nese si ji s sebou i do metody \verb|foo|, odkud je poté zavolán (pomocí klíèového slova \verb|yield|). Ukázka výpí¹e èíslo 30, proto¾e \verb|a| je lokální promìná z kontextu, ve kterém byl pøedaný blok vytvoøen. Pokud by chtìla metoda \verb|foo| vytisknout svou hodnotu promìné \verb|a|, musela by ji pøedat jako parametr.

\subsubsection{Drobnosti}
U¾ bych se chtìl u¾ jenom krátce zmínit o nìkolika málo dal¹ích vlastnostech ruby, které popisem nevydají na samostatnou kapitolu, ale pøesto si myslím, ¾e by zde mìly být uvedeny.

Mimo toho, ¾e v¹e je v ruby objekt, je ka¾dá jazyková konstrukce výraz (má svou hodnotu). Tedy i øídicí konstrukce (\verb|if|, \verb|while|, ...) nìco vrací - podle funkce pøíslu¹né konstrukce je to tøeba poslední vykonaný pøíkaz nebo \verb|nil|. Pøiklad z øádkového interpretu ruby \verb|irb|:

\begin{verbatim}
irb(main):001:0> if 1 == 2
irb(main):002:1>   puts "1 == 2"
irb(main):003:1> end
=> nil
\end{verbatim} 

Ruby je plnì objektový a v¹e je objekt nebo jeho metoda -- i aritmetické operátory jsou ve skuteènosti metody a jejich zápis bez pøístupové teèky je jen ''syntax sugar`` (jak se uvádí v knize  The Ruby Programming Language\cite{rubyProgrammingLanguage}). Jde je tedy podobnì jako v C++ pøetí¾it nebo z daného objektu úplnì odstranit:

\begin{verbatim}
irb(main):001:0> class Fixnum
irb(main):002:1>   def +(oth)
irb(main):003:2>     self * oth
irb(main):004:2>   end
irb(main):005:1> end
=> nil
irb(main):006:0> 4 + 2
=> 8
\end{verbatim} 

Ruby podporuje pouze jednoduchou dìdiènost (tøída mù¾e mít maximálnì jednoho pøedka), ale absenci implementaènì slo¾ité vícenásobné dìdiènosti vynahrazuje mo¾ností vkládat do sebe moduly (modul je jednodu¹e øeèeno kolekce metod):

\begin{verbatim}
irb(main):001:0> module Ahoj
irb(main):002:1>   def ahoj
irb(main):003:2>     puts "Ahoj"
irb(main):004:2>   end
irb(main):005:1> end
=> nil
irb(main):006:0> class Pozdravy
irb(main):007:1>   include Ahoj
irb(main):008:1> end
=> Pozdravy
irb(main):009:0> p = Pozdravy.new
=> #<Pozdravy:0x82945b4>
irb(main):010:0> p.ahoj
Ahoj
\end{verbatim}

Na rozdíl od C/C++ èi Javy jsou v ruby povoleny na konci metod jiné znaky ne¾ jen znaky anglické abecedy. Co¾ má veliký dopad na zlep¹enou èitelnost k\'{o}du, jeliko¾ podle konvencí metody vracející booleanovskou hodnotu (true/false) jsou ukonèeny znakem otázníku (napøíklad \verb|Object#nil?|) a metody mìnící stav samotného objektu jsou pro zmìnu ukonèeny vykøièníkem (napøíklad \verb|Array#map!|).

\subsection{Ostatní implementace ruby}
Nejznámìj¹í a asi i nejvíce pou¾ívanou implementací jazyka Ruby je interpret MRI (Mat'z ruby interpreter) od autora jazyka. Ten má ov¹em své nedostatky (není nejrychlìj¹í, neumo¾nujì opravdový paralerismus proto¾e obsahuje ''Global interpreter lock`` - v jednu chvíli mù¾e bì¾et maximálnì jedno vlákno). Jako podklad pro tento list jsem pou¾il seznam rùzných interpretù a jejich krásné srovnání na webu igvita\cite{webIgvitaInterprets}.

\subsubsection{Ruby Enterprise edition}
Jde o fork MRI implementace verze 1.8.7\cite{webRubyEE} s vylep¹enou správou pamìti a vymìnìným garbage collectorem (MRI vyu¾ívá mark-and-sweep GC). Vznikl jako potøeba optimalizovat ruby pro bìh na serverech pro webové aplikace postavené na Ruby on Rails a je pro nì optimalizován. Je plnì kompatibilní s ruby verze 1.8.7 a podle oficiálních stránek v urèitých pøípadech a¾ o 33\% rychlej¹í. Na portále RubyInside\cite{webRubyEERecord} je k dispozici záznám pøedná¹ky obou autorù toho forku z konference Google Tech Talk (2009, San Francisco), o dùvodech proè se do forku pustili a také o optimalizacích, které provedli.

\subsubsection{JRuby}
Je implementace ruby v Jave\cite{webJRuby} a vyu¾ívající mo¾ností Java VM - obsahuje plnou paralerizaci (¾ádný GIL), v souèastosti se pracuje na podpoøe ruby verze 1.9. Velmi ¾ivý projekt se 7 aktivními vývojáøi (MRI z nejvìt¹í èásti vyvíjí jeden èlovìk).

\subsubsection{BlueRuby}
Jedná se o implementaci ruby bì¾ícího uvnitø SAP NetWeaver a SAP ERP produktù, tedy dal¹í mo¾nost jak roz¹íøit SAP mimo jazykù ABAP a Java. Zatím je projekt pouze ve stádiu experimentální implementace\cite{webBlueRuby} a nehodí se pro reálné nasazení - je naimplementováno pouze okolo 75\% vlastní ruby podle ruby specs.

\subsubsection{Rubinius}
Zajimavý nápad napsat co nejvìt¹í èást ruby v samotném ruby\cite{webRubinius} - jedná se o pøepsaní nezbytnì nutných èástí interpretu do C++ a zbývajícího k\'{o}du do ruby (jako napøíklad standartní tøídy - String, Array, Hash, ...). Intepret obsahuje JIT kompilátor - parsovaný skript kompiluje na místì do binárního k\'{o}du spustitelném na dané platformì a a¾ ten následnì spou¹tí, èím¾ dosahuje zrychlení oproti MRI. Díky kompilaci do nativního k\'{o}du není zatí¾en GIL a tedy umo¾nuje paralerismus. V souèasné dobì je tento projekt stále ve vývoji - nìkolik gemù a aplikací v nìm ji¾ bì¾í, ale pro reálné nasazení není pøíli¹ vhodný.

\subsection{Mo¾nosti binárního roz¹íøení}
TODO


\section{Expertní systémy}
TODO: Popsat co jsou vlastne expertni systemy, jak se s nimi pracuje, cim se lisi od ostatnich, trochu historie.

\subsection{Clips}
TODO: Popsat historii CLIPS, co to je v dnesni dobe. Prakticke ukazky jak se v clips pracuje. Zahrnout kapitolu o rozsiritelnosti.

%=========================================================================
\chapter{rbClips}
%=========================================================================
TODO: Par vet o tom co jsme se rozhodli vytvorit a proc (proc wrapper nad necim co uz existuje).
TODO: Vlastni text...

%=========================================================================
\chapter{Závìr}
%=========================================================================
TODO: Taky by se hodil ze jo... ;-)
