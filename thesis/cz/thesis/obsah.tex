%=========================================================================
\chapter{Úvod}
%=========================================================================
Poèet novì se objevujících virù a jiných ¹kodlivých poèítaèových k\'{o}dù (malwaru) rok od roku stoupá. Velice tomu pomáhá postupné roz¹iøování internetu i mezí ménì informovanou laickou veøejnost, která se pøíli¹ netrápí dostateèným zapezpeèím svých poèítaèù. Tento nepøíli¹ optimistický trend zpùsobuje prolémy snad ve v¹ech odvìtvích, proto¾e dnes u¾ bez IT oddìlení nemù¾e existovat ¾ádná vet¹í firma. Zpùsobené problémy jsou hlavnì finanèí\,--\,rostou náklady jak na zabezpeèení jednotlivých poèítaèových stanic, tak i celých poèítaèívých sítí.

Logickou úvahou by mohl ètenáø dojít k názoru, ¾e na tomto trendu mimo spamerù profitují hlavnì rùzné bezpeèností firmy. Nejvíce pak antivirové spoleènosti, dodavající ochraná øe¹ení proti malwaru. \v{S}kodlivého k\'{o}du je ov¹em nejenom více, ale bohu¾el se takté¾ dost mìní. Jeho autoøi, kterých je stále více, vynalézají nové a dùmyslnìj¹í techniky jak pøedejít odhlanení antivirovým programem. Co¾ na stranì antivirových firem zmanená poptávku po stále vìt¹ím poètu velice dobøe kvalifikovaných lidí pro procházení podezøelých vzorkù a vytváøení nových virových definic.

Dostateèný poèet dobøe kvalifikovaných lidí bohu¾el na trhu práce není k dispozici a proto se hledají jiné, automatizovanìj¹í postupy, pro zpracování podezøelých vzorkù. Automatizované postupy mají navíc i jiné výhody. Poèítaè pracuje rychleji, mnohdy spolehlivìji a hlavnì výraznì levnìji ne¾ jeho lidský ekvivalent. Na druhou stranu mu chybí takzvaný ``zdravý selský rozum''. Pøirozené lidské my¹lení se jen velmi obtí¾nì implementuje do obvyklých procedurálních programù.

Pro adresaci problému lidského uva¾ovaní vznikly tkz. expertní systémy. Expertní systém je program, který napodobuje rozhodovací proces lidského experta podle pøedem nadefinovaných pravidel. V rámci spoleènosti AVG Technologies s.r.o jsme se rozhodli vytvoøit program za pou¾ití expertního systému pro automatickou klasifikaci vzorkù. Vìt¹ina expertních systému je komerèních a vzhledem k tomu, ¾e se nejedná o levné programy rozhodli jsme pou¾ít volnì ¹íøitelný pøíklad takového systému jménem CLIPS.

CLIPS je public domain software, je tedy zadarmo i pro komerèní vyu¾ití. Nabízí plnohodnotné prostøedí pro tvorbu expertního systému, které je napsáno v jazyce C. U¾ivatelské rozhrání, které je velice podobné jazyku LISP, je ov¹em u¾ivatelsky velice nepøívìtívé. Proto jsme se rozhodli celé CLIPS vzít a zapouzdøit do nìjakého vy¹¹ího programovacího jazyka. Jako cílový jazyk pro zapouzdøení jsme se rozhodli vyu¾ít moderní skriptovací jazyk Ruby, kvùli jeho zajimavým a neobvyklým mo¾nostem.

Má bakaláøská práce, která je v následujícíh kapitolách popsána, pojednává o novì vytvoøené knihovnì rbClips, která umo¾nuje pou¾ívat CLIPS v jazyce Ruby. Knihovna bude následnì pou¾ita k tvorbì systému pro automatické rozpoznávání vzorkù, tak jak bylo nastínìní na pøedcházejícíh øádcích. Samotný systém pro klasifikaci vzorkù u¾ ov¹em není rozsahém této práce.

V druhé kapitole bych rád popsal obì nastínìné technologie, které spojím do funkèního celku více do detailu. Budu se tedy pøednì vìnovat systému pro tvorbu expertních systému CLIPS a dynamickému skriptovacímu jazyku Ruby.

Tøetí kapitola je ji¾ popisem mé knihovny. Obsahuje jak její návrh, popis rozhraní tak i rùzné zajímavé implementaèní dropnosti.

%=========================================================================
\chapter{Pou¾ité technologie}
%=========================================================================
Jak jsem popsal v úvodu, cílem mé bakaláøské práce je vytvoøit knihovnu rbClips umo¾nující propojit CLIPS a Ruby. V následujících dvou kapitolách se obìma technologiím budu zabývat více do hloubky a vysvìtlím proè jsme se rozhodli pou¾ít právì je. Obì technologie jsou napsány v programovacím jazyce C, proto i moje knihovna bude napsána tém¾e jazyce. Samotný popis jazyka C jsem ji¾ ov¹em do své práce nezahrnul a lze najít napøíklad v knize \cite{programovaciJazykC}.

\section{Ruby}
Ruby\cite{webRuby} je relativnì mladý dynamický skriptovací jazyk vytvoøený japonským in¾enýrem Yukihiro Matsumoto známym pod pøezdívkou Matz. V souèasné dobì neexistuje ¾ádná specifikace èi norma jako je tomu napøíklad u jazykù C/C++ a dal¹ích. Z tohoto dùvodu se jako reference jazyka bere samotný interpret napsaný Matzem\,--\,Matz' ruby intepret (MRI). Interpretù existuje více a jejich zkrácený seznam je uveden dále v textu. Absence existujícího standartu vedla v roce 2008 k vytvoøení skupiny pro standardizaci jazyka v rámci japonské organizace Information-technology Promotion Agency (IPA), která vychází z MRI verze 1.8.7. V souèasné dobì je k dispozici ji¾ návrh standartdu\footnote{http://ruby-std.netlab.jp/draft\_spec/agreement.html}, který má být navr¾en ke schválení prvnì v japonsku u Japanese Industrial Standards Committee (JISC) a následnì i u International Standard Organization (ISO).

\subsection{Historie}
První verze interpretu Ruby vytvoøená Matzem byla zveøejnìna u¾ v roce 1995 (velice zajimavý je fakt, ¾e jméno nového jazyka u¾ bylo vybráno v roce 1993, tedy o cele dva roky døíve), ov¹em oficální webové stránky jazyka v angliètinì byly k dispozici a¾ o tøi roky pozdìji\,--\,tedy v roce 1998. Absence kvalitních materiálù v angliètinì je jedním z hlavních dùvodù, proè se Ruby stal populárním prvnì pouze v Japonsku a velice pomalu se dostával i do ostatních státu svìta. V dne¹ní dobì u¾ na¹tìstí není problém najít kvalitní zdroje informací ani v angliètinì ani v èe¹tinì, èi dál¹ích jazycích, a to jak ve webové tak i v kni¾ní podobì. Tyto i dal¹í zajimavá data jsou shrnuta na Obrázku \ref{ruby_history}, která jsem èerpal z prezentace vytvoøené k pøíle¾itosti konference RubyConf 2006\footnote{http://blog.nicksieger.com/articles/2006/10/20/rubyconf-history-of-ruby}.

Matz vytvoøil nový jazyk, proto¾e ho nadchly mo¾nosti skriptovacích jazyku a ¾adný z tehdy dostupných jazykù ho nezaujal\footnote{http://linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html} - chtìl jazyk mocnìj¹í ne¾ Perl\footnote{http://www.perl.org/} a více objektì orientovaný ne¾ Python\footnote{http://www.python.org/}.  Na otázku, proè vytvoøil dal¹í skriptovací jazyk, Matz je¹tì èasto dodává dùvody syntaxe - programovacích jazykù je mnoho a jsou svým zpùsobem velice podobné (vlastnostmi i schopnostmi). Matz ov¹em chtìl jazyk, ve kterém ho bude bavit psát a nebude se muset pøíli¹ trápit se zápisem jednotlivých konstrukcí. Syntaxe by mìla být podøízena èlovìku jako¾to pisateli jazyka, nikoliv opaènì poèítaèi jako¾to interpretu jazyka.

\begin{figure}[tbh]
  \begin{tabular}{|c|l|}
    \hline
    1993 & Vybráno jméno \\
    1995 & První zveøejnìná verze interpretu (verze 0.95) \\
    1996 & Verze 1.0 \\
    1997 & Matz zamìstnán jako full-time ruby programátor \\
    1998 & Webové stránky v angliètinì a vznik anglicky psaného mailing listu \\
    1999 & První kniha o ruby (psána japonsky) \\
    2000 & Zaèátek roz¹iøování povìdomí o ruby mimo hranice Japonska \\
    2001 & YARPC - Yet Another Ruby and Perl Conference \\
    \hline
  \end{tabular} 

  \caption{Shrnutá historie v datech}
  \label{ruby_history}
\end{figure}

V souèasné verze se udr¾ují dvì hlavní vìtve MRI\,--\,verze 1.8 a 1.9. Vìtev 1.8 je pova¾ována za stabilní a ji¾ se pouze udr¾uje (opravují se chyby), hlavní vývoj probíhá ve vìtvi~1.9.

\subsection{Vlastnosti ruby}
Ruby je dynamický skriptovací jazyk mnoha ruzných paradigmat\,--\,je plnì objektovì orientovaný, ale lze v nìm bez problémù psát i imperativnì èi funkcionálnì. Následuje popis vybraných vlastností, které bych rád vyzdvihl èi na nì upozornil. Podle poøeby budu dále v textu srovnávat Ruby s dal¹ímy jazyky které znám - Java\footnote{http://www.java.com/en/} a C++\footnote{http://www.cplusplus.com/}.

Ní¾e uvedený popis vlastností jsem èerpal ze své osobní zku¹enosti s tímto programovacím jazykem. Z velice obsáhleho popisu jazyka napsaného samotným autorem Ruby The Ruby programming language\cite{rubyProgrammingLanguage}. Co¾ je zrevidoví a roz¹íøení døíve vydané knihy Ruby in Nutshel\cite{rubyInNutshel}. A z knihy Metaprogramming Ruby\cite{metaprogrammingRuby}, která se zabývá nejen metaprogramováním v Ruby, ale také velice èitelným zpùsobem vysvìtluje objektový model ruby a dal¹í jeho aspekty.

Dále bych se rád blí¾e zabýval popisem objektovosti Ruby, jeho volnìj¹í syntaxí, dynamiènosti, otevøeností a popisu jak fungují bloky.

\subsubsection{Objektovost}
Ruby je plnì objektovì orientovaný jazyk (byl mimo jiné inspirován i Smalltalkem\footnote{http://www.smalltalk.org/main/}), co¾ znamená, ¾e v¹e v Ruby je objekt. Nejsou zde ¾ádná datová primitiva jako v Javì (int, double) a C++. \u{C}íselné a jiné konstanty jsou interpretem okam¾itì pøevádìny na instance pøíslu¹ných tøíd. Pøíklad na Obrázku \ref{ruby_objektovost_fig1} ukazuje mo¾nost volání metody na èíselnou konstantu bez nutnosti explicitní objektivizace.

\begin{figure}[tbh]
	\begin{verbatim}
	123.class # => Fixnum
	\end{verbatim}
  \vspace{-0.7cm}
  \caption{Automatická objektivizace èíselných konstant}
  \label{ruby_objektovost_fig1}
\end{figure}

Interpret po svém startu vytvoøí bezejmenou instanci tøídy Object a v jejím kontextu naslednì vykoná pøedaný skript. Odpadá tedy nutnost explicitnì vytváøet tøídu s minimálnì jednou veøejnou metodu, která se spustí po startu aplikace jako je tomu v Javì nebo funkci main() v pøípadì C++. Ukázkový ``Hello world!'' program, který v Ruby vypadá takto: \verb|puts "Hello world!"|, je tedy objektový k\'{o}d, i kdy¾ se tak na první pohled nezdá. Tvrzení lze dokazát vypsaním tøídy aktualního objektu \verb|puts self.class|, která vratí ``Object'' i kdy¾ pro pisatele v ¾ádném objektu není (\verb|self| je obdoba ukazatele \verb|this| z jazyka C++, tedy ``ukazatel'' na aktuální objekt),

Dal¹í a pro mì v dobì, kdy jsem se s Ruby poprvé seznamoval, velice pøekvapivý dùsledek plné objektovosti je fakt, ¾e tøídy samy jsou objekty. Napøíklad objekt ``abcd'' je tøídy \verb|String|, a samotná tøída/objekt \verb|String| je zase tøídy \verb|Class|, co¾ jde vidìt na Obrázku \ref{ruby_objektovost_fig2}. Z tohoto pøístupu plynì nìkolik dùsledkù: (1) je potøeba rozli¹ovat mezi tøídní metodou a instaèní metodou, (2) tøídy mohou mít své instaèní promìné, (3) existuje mo¾nost dìdit i na mno¾inì objektù, ze kterých se vytváøejí tøídy. Z praktického pohledu se na tuto vlastnost lze koukat jako na statické promìné a metody u jazyka C++.

\begin{figure}[tbh]
	\begin{verbatim}
	"abc".class # => String
	String.class # => Class
	\end{verbatim}
  \vspace{-0.7cm}
  \caption{Ruby tøída je plnohodnotný objekt}
  \label{ruby_objektovost_fig2}
\end{figure}

Schopnosti dìdit na mno¾inì objektù, ze kterých se vytváøejí tøídy vyu¾ívá i objektový model Ruby. Tøída \verb|Class| pou¾ívaná pro tvorbu tøíd dìdí od tøídy \verb|Modul|, kterou roz¹iøuje hlavnì o metodu \verb|new| slou¾ící pro tvorbu nových instancí. Modul je zjednodu¹ená tøída, kolekce metod, od které nelze vytváøet instance ov¹em lze je vkládat dovnitø jiných tøíd a tím nahrazovat absenci vícenásobné dìdiènosti v Ruby.

%\begin{figure}[ht]
%  \centering
%  \includegraphics[width=8cm,keepaspectratio]{fig/fig-ruby-inst_obj.png}
%  \caption{Promìné, metody a jejich umístìní v instancích a tøídách}
%  \label{fig_ruby_inst_obj}
%\end{figure}
%
%Tøídy jsou v ruby také objekty (instance jiné tøídy - konkrétnì tøídy Class) - mají tedy své instanèní promìné a lze na nich volat metody (které %jsou umístìny v tøídì dané tøídy).
%
%\begin{figure}[ht]
%  \centering
%  \includegraphics[width=12cm,keepaspectratio]{fig/fig-ruby-inst_obj_2.png}
%  \caption{Tøída je také objekt}
%  \label{fig_ruby_inst_obj_2}
%\end{figure}

\subsubsection{Volná syntaxe}
Jak u¾ bylo zmínìno vý¹e, Matz chtìl vytvoøit jazyk, ve kterém by ho bavilo programovat. Jazyk ve kterém by nemusel poøád pøemý¹let nad syntaxí, který by byl krásnì èitelný a hlavnì pokud mo¾no co nejbli¾¹í bì¾nému lidskému jazyku. Cíl se mu povedl, proto¾e ukázky k\'{o}du (viz Obrázek \ref{ruby_syntaxe_fig1}) opravdu pøi ètení pøipomínájí anglické vìty, popisující co se má udìlat.

\begin{figure}[tbh]
	\begin{verbatim}
	3.times do puts 'Ahoj'
	puts "Ahoj" if name == "jarcec"
	\end{verbatim} 
	\vspace{-0.7cm}
  \caption{Ukázky èitelnosti k\'{o}du}
  \label{ruby_syntaxe_fig1}
\end{figure}

Jedním ze zpùsobu pøízpùsobìní gramatiky jazyka programátorovi je mo¾nost nepsat závorky oddìlující název metody od jejich parametrù v místech, kde to není syntakticky nejednoznaèné. Mohu tedy zavolat metodu \verb|naDruhou| s parametrem 5 tak jak je zvykem v Javì/C++ \verb|naDruhou(5)|, nebo na mnoha místech více èitelnìji \verb|naDruhou 5|. Volání metod bez závorek vypadá na mnoha místech spí¹e jako klíèové slovo s cílem nìco deklarovat ne¾ obyèejné volání metody.

\begin{figure}[tbh]
	\begin{verbatim}
	class Human < ActiveRecord::Base
		has_many     :articles
		belongs_to   :department
	end
	\end{verbatim} 
	\vspace{-0.7cm}
  \caption{ActiveRecord ukázka prezentující volitelné vynechání závorek}
  \label{ruby_syntaxe_fig2}
\end{figure}

Na první pohled se to mù¾e jevit spí¹e jako matoucí, ale uvedený  pøíklad (Obrázek \ref{ruby_syntaxe_fig2}) z webového frameworku Ruby on Rails\footnote{http://rubyonrails.org/} (dále v textu pou¾ívám zkratku RoR) ukazuje opak. I èlovìk bez znalosti Ruby nebo RoR, ov¹em se znalostí jiného programovacího jazyka, je schopen s velkou úspì¹ností odhadnout, ¾e prezentovaný pøíklad vytváøí tøídu Human, s urèitou závislostí na oddìlení (department), a který napsal mnoho rùzných èlánkù (articles).

Tento spí¹e sociální efekt (``Jedná se o metodu nebo klíèové slovo?'') jde v Ruby velice hluboko. Mnohdy lze u¾ úvodních tutoriálech najít zmínku o klíèovém slovì \verb|puts| slou¾ícímu pro výpis na standartní výstup (obdoba \verb|printf()| z C, \verb|echo| z Bashe nebo \verb|print| z Perlu). Ve skuteènosti se ov¹em nejedná o klíèové slovo, ale o metodu modulu \verb|Kernel|, který ka¾dy objekt zdìdí a proto je na ka¾dém místì programu dostupná. Jedná se tedy zcela normální metodu a jde stejnì jako jakákoliv jíná v pøípade potøeby pøetí¾it popøípadnì z objektu odstranit...

Odstranìní nutnosti psát v¹ude závorky beru jako kladnou vlastnost, kterou velice èasto a rád vyu¾ívám. Na druhou stranu ov¹em musím upozornit na její dopady - i pouhá mezera mù¾e zmìnit logiku kódu s jakou bude zpracován. Na Obrázku \ref{ruby_syntaxe_fig3} uvadím dva pøíklady li¹ící se pouhou jednou mezerou mezi koncem názvu metody a otevírající závorkou. V prvním pøípadì syntaktický analyzátor najde ihned za názvem metody závorku. Ví tedy, ¾e uvnitø se nacházejí parametry, se kterými se metoda má volat a a¾ následná vrácená hodnota se vynasobí dvìma. Výsledek bude $18$ (=$3^2  * 2$). V druhém pøíkladì syntaktický analyzátor najde za názvem metody mezeru a pøístupuje k volání jinak. Ví, ¾e následuje seznam argumentù oddìlený èárkami, proto¾e závorky okolo argumentù jsou vynechány. Na øádce se ov¹em ¾ádná èárka nenachazí a tedy celý výraz $(1+2)*2$ je metodì pøedán jako jeden argument s výsledkem $36$ (=$((1+2) * 2)^2$).

\begin{figure}[tbh]
	\begin{verbatim*}
	puts naDruhou(1+2)*2
	puts naDruhou (1+2)*2
	\end{verbatim*}
 	\vspace{-0.7cm}
  \caption{Dùle¾itý význam mezer}
  \label{ruby_syntaxe_fig3}
\end{figure}

Ruby neumo¾nuje pojmenovat argumenty metod podobnì jako python, ov¹em díky volné syntaxi pro vytvoøení asociativního pole (hashe) lze toto chování napodobit. Pøíkladem mù¾e být volání fiktivní metody pro hledání \verb|find :name => 'Jarek', :surname => 'Cecho'|, kde opticky pøedávám dva pojmenované parametry - name a surname. Ve skuteènosti je tento zápis reprezentován jako tvorba asociativního pole s klièi name a surname a a¾ naslednì je toto pole pøedáno metodì \verb|find| jako jeden argument. Webový framework Ruby on Rails tento pøístup pou¾ívá velmi èasto.

Poslední poznámka k volné syntaxi, Ruby umo¾nuje stejnì jako Perl otoèení poøadí zápisu neúplné podmínky a jejího tìla (viz. Obrázek \ref{ruby_syntaxe_fig3}).

\begin{figure}[tbh]
	\begin{verbatim}
	if osoba == 'jarcec' then print "Ahoj Jarcec"; end
	print "Ahoj Jarcec" if osoba == 'jarcec'
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøehození poøadí zápisu neúplnì podmínky a jejího tìla}
  \label{ruby_syntaxe_fig4}
\end{figure}

\subsubsection{Dynamiènost a otevøenost}
Dynamièností Ruby rozumím provádìní mnoha èinností, které jsou provádìny v pøípadì C++ èi Javy v dobì kompilace, a¾ za bìhu programu. Vzhledem k plné objektovosti nemá moc smysl mluvit o typovosti jazyka, proto¾e existuje pouze jediný datový typ, kterým je objekt.

Z dynamiènosti vyplývá mnohem zajimavìj¹í a ne a¾ tak bì¾ná vlastnost Ruby, kterou je otevøenost. Ka¾dý objekt mù¾e být za bìhu otevøen a roz¹íøen o nové metody podobnì jako je tomu u JavaScriptu. Velice \u{c}asto se toho vyu¾ívá u tøíd (napøíklad roz¹íøením vìstavìné tøídy o nové metody). Tuto vlastnost by do urèité míry ¹lo nahradit dìdièností (nové metody ulo¾it do potomka), ale jen pokud se roz¹iøují tøídy. V Ruby je v¹e objekt, tak¾e roz¹íøit jdou nejen tøídy, ale dokonce i instance jednotlivých tøíd (viz Obrázek \ref{ruby_dynamicnost_fig1}), co¾ byl pro mì jako¾to programátora v C++ docela ¹ok pøi seznamování se s tímto jazykem. Mo¾nosti roz¹íøení instancí o nové metody pou¾ívám i ve své práci, co¾ popisuji ní¾e v kapitole o zpracování Faktù.

\begin{figure}[tbh]
	\begin{verbatim}
	class A
	def metodaA
			4
		end
	end

	a = A.new
	a.metodaA # => 4

	b = A.new
	def b.metodaB
		5
	end
	b.metodaB # => 5
	a.metodaB # => Exception NoMethodError
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøehození poøadí zápisu neúplnì podmínky a jejího tìla}
  \label{ruby_dynamicnost_fig1}
\end{figure}

Díky dynamiènosti a otevøenosti se v ruby velice pìknì metaprogramuje (co¾ je mnohoznaèný výráz, zde pou¾ívám ve významu psaní k\'{o}du, který generuje dal¹í k\'{o}d). Jedná se o velice èasto vyu¾ívanou schopnost jazyka a velké projekty v Ruby jsou metaprogramováním dosti ovlivnìny. Pøíkladem mù¾e být projekt ActiveRecords\footnote{http://ar.rubyonrails.org/}, který zapouzdøuje èinnost s relaèními databázemi tak, aby se u¾ivatel se SQL vùbec nesetkal. V¹e je pro nìj zapouzdøeno do objektù.

\begin{figure}[tbh]
	\begin{verbatim}
	class Human < ActiveRecords::Base
	end

	jarcec = Human.new
	jarcec.name = "Jarek"
	jarcec.surname = "Cecho"
	jarcec.save
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ukázka pou¾ití knihovny ActiveRecords}
  \label{ruby_dynamicnost_fig2}
\end{figure}

V definici tøídy z Obrázku \ref{ruby_dynamicnost_fig2} chybí deklarace method \verb|name| a \verb|surname| a pøesto daný k\'{o}d bude fungovat. Konstruktor tøídy se toti¾ pøi inicializaci podívá do databáze na strukturu tabulky kterou popisuje, v tomto pøípadì tabulky \verb|humans| a vytvoøí ke v¹em nalezeným sloupcùm pøíslu¹né metody pro ètení i zápis. Tento pøístup velice usnad\u{n}uje údr¾bu k\'{o}du. V definice tøídy není seznam sloupcù jednotlivých tabulek a proto pøi zmìnì databázového schématu není nutné v¹e upravovat a zvedat tak pravdìpodobnost zavleèení chyby díky nekonzistenci seznamu sloupcù v databázi a v definici tøídy.

O metaprogramování v ruby byla napsána velice pìkná kniha - Metaprogramming Ruby\cite{metaprogrammingRuby}. Psána je spí¹e laickým stylem a na praktických pøíkladech popisuje co pøesnì se pod pojmem metapogramovaní skrývá, a jak toho v ruby co nejefektivnìji vyu¾ít.

\subsubsection{Bloky}
Blok je podobnì jako v C++ nebo Javì mno¾ina pøíkazù ohranièená slo¾enymí závorkami. V pøípadì Ruby je je¹tì mo¾né blok ohranièit klíèovými slovy \verb|do| a \verb|end|. Na rozdíl od zmínìných jazykù v Ruby jde s bloky dìlat o dost vìt¹í kouzla a proto je zmi\v{n}uji v samostatné èásti. První dùle¾itý rozdíl je mo¾nost pøedat bloku parametry (a ten se pak vlastnì chová jako bezejmená funkce). Dal¹í rozdíl je schopnost bloky v Ruby pøedávát do method.

\begin{figure}[tbh]
	\begin{verbatim}
	["AHOJ", "NAZDAR", "HI"].map{|prvek| prvek.downcase}
			# => ["ahoj", "nazdar", "hi"]
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ukázka pøedání bloku metodì}
  \label{ruby_bloky_fig1}
\end{figure}

Pøíkladem mù¾e být zámìna velikosti písmen v poli øetezcù na Obrázku \ref{ruby_bloky_fig1}. Metoda \verb|map| tøídy \verb|Array| pøijímá blok akceptující jeden parametr a pro ka¾dý prvek v poli tento blok zavolá. Návratovou hodnotu bloku (v Ruby je v¹e výraz, i bloky tedy vracejí své hodnoty, tato vlastnost je detailnìji popsána ní¾e) ulo¾í do pole na místo volaného prvku. Ukázka tedy zmen¹í velikost písmen pro kazdý prvek v poli.

S bloky se pojí jeden dùle¾íty pojem - uzávìr (anglicky closure). Ka¾dý blok si s sebou nese vazby na lokální promìné známé v dobì jeho vzniku (takzvané bindings). V pøíkladì na Obrázku \ref{ruby_bloky_fig2} si blok ``zapamatuje`` svou lokální promìnou \verb|a| (s hodnotou 30) a nese si ji s sebou i do metody \verb|foo|, odkud je poté zavolán (pomocí klíèového slova \verb|yield|). Ukázka výpí¹e èíslo 30, proto¾e \verb|a| je lokální promìná z kontextu, ve kterém byl pøedaný blok vytvoøen. Pokud by chtìla metoda \verb|foo| vytisknout svou hodnotu promìné \verb|a|, musela by ji pøedat do bloku pøes parametr.

\begin{figure}[tbh]
	\begin{verbatim}
	def foo
		a = 10
		yield # Zavolej predany blok
	end

	a = 30
	foo { puts a } # Vytiskne hodnotu promene a, ale ktere? 10 nebo 30?
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Vazby na lokální promìné v pøípadì pøedaných blokù}
  \label{ruby_bloky_fig2}
\end{figure}


\subsubsection{Drobnosti}
Dále bych se chtìl u¾ jenom krátce zmínit o nìkolika vlastnostech Ruby, které popisem nevydají na samostatnou èást, ale pøesto si myslím, ¾e by zde mìly být uvedeny.

Mimo faktu, ¾e v¹e je objekt, je ka¾dá jazyková konstrukce výraz (má svou návratovou hodnotu). Tedy i øídicí konstrukce (\verb|if|, \verb|while|, ...) nìco vrací - podle funkce pøíslu¹né konstrukce je to tøeba poslední vykonaný pøíkaz nebo \verb|nil| (Obrázek \ref{ruby_drobnosti_fig1}).

\begin{figure}[tbh]
	\begin{verbatim}
	if 1 == 2
	  puts "1 == 2"
	end # => nil
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig1}
\end{figure}

Ruby je plnì objektový a v¹e je objekt popøípadnì jeho metoda. I aritmetické operátory jsou tedy ve skuteènosti metody a jejich zápis bez pøístupové teèky je jen ''syntax sugar`` (jak se doslovnì uvádí v knize  The Ruby Programming Language\cite{rubyProgrammingLanguage}). Jde je tedy podobnì jako v C++ pøetí¾it nebo z daného objektu úplnì odstranit (Obrázek \ref{ruby_drobnosti_fig2}).

\begin{figure}[tbh]
	\begin{verbatim}
	class Fixnum
	  def +(oth)
	    self * oth
	  end
	end #	=> nil
	4 + 2 #	=> 8
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig2}
\end{figure}

Ruby podporuje pouze jednoduchou dìdiènost, co¾ znamená, ¾e tøída mù¾e mít maximálnì jednoho pøedka. Ov¹em absenci implementaènì slo¾ité vícenásobné dìdiènosti vynahrazuje mo¾ností vkládat do sebe moduly (Obrázek \ref{ruby_drobnosti_fig3}).

\begin{figure}[tbh]
	\begin{verbatim}
	module Ahoj
	  def ahoj
	    "Ahoj"
	  end
	end
	class Pozdravy
	  include Ahoj
	end
	p = Pozdravy.new
	p.ahoj # => "Ahoj"
\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Ka¾dá jazyková konstrukce je výraz}
  \label{ruby_drobnosti_fig3}
\end{figure}

Na rozdíl od C++ èi Javy jsou v Ruby povoleny na konci metod i jiné znaky ne¾ jen znaky anglické abecedy. Co¾ má veliký dopad na zlep¹enou èitelnost k\'{o}du, jeliko¾ podle konvencí metody vracející booleanovskou hodnotu (true/false) jsou ukonèeny znakem otázníku (napøíklad \verb|Object#nil?|) a metody mìnící stav samotného objektu jsou pro zmìnu ukonèeny vykøièníkem (napøíklad \verb|Array#map!|).

\subsection{Implementace Ruby}
Nejznámìj¹í a asi i souèasnì nejvíce pou¾ívanou implementací Ruby je interpret MRI (Mat'z ruby interpret) od autora jazyka. Ten má ov¹em své velké nedostatky. Pøednì pou¾ívá mark-and-sweep garbage collector. Ten v rámci své ''mark`` fáze zmrazí provádìní programu, co¾  se neblaze odrází na celkové rychlosti interpretace. Dále obsahuje takzvaný ''Global interpreter lock`` (GIL), který znemo¾nuje paralelní zpracování. Programy sice mohou be¾et ve vláknech, ale kvùli jeho pøítomnosti mù¾e v jednu chvíli bì¾et maximálnì jedno vlákno.

Jako podklad pro následný list alternativních implementací jsem pou¾il seznam interpretù a jejich krásné srovnání na webu igvita\footnote{http://www.igvita.com/2009/11/20/state-of-ruby-vms-ruby-renaissance}.

\subsubsection{Ruby Enterprise edition}
Jde o vývojovou vìtvi (fork) MRI implementace verze 1.8.7\footnote{http://www.rubyenterpriseedition.com/index.htm} s vylep¹enou správou pamìti a vymìnìným garbage collectorem. Vznikl jako potøeba optimalizovat ruby pro bìh na serverech pro webové aplikace postavené na Ruby on Rails a je pro nì optimalizován. Je plnì kompatibilní s ruby verze 1.8.7 a podle oficiálních stránek v urèitých pøípadech a¾ o 33\% rychlej¹í. Na portále RubyInside je k dispozici záznám pøedná¹ky\footnote{http://www.rubyinside.com/how-phusion-built-a-more-efficient-ruby-1-8-interpreter-2906.htm} obou autorù  z konference Google Tech Talk (2009, San Francisco), o dùvodech proè se do úprav pustili a také o optimalizacích, které provedli.

\subsubsection{JRuby}
Je implementace ruby v Javì\footnote{http://jruby.org} a vyu¾ívající mo¾ností Java VM - obsahuje plnou paralelizaci (¾ádný GIL). V souèastosti se pracuje na podpoøe ruby verze 1.9. Velmi ¾ivý projekt se 7 aktivními vývojáøi (MRI z nejvìt¹í èásti vyvíjí pouze jeden èlovìk).

\subsubsection{BlueRuby}
Jedná se o implementaci Ruby bì¾ícího uvnitø SAP NetWeaver\footnote{www.SAP.com/cz/ERP} a SAP ERP produktù, tedy dal¹í mo¾nost jak roz¹íøit platformu SAP mimo jazykù ABAP\footnote{http://help.sap.com/saphelp\_nw70/helpdata/en/fc/eb2e97358411d1829f0000e829fbfe/frameset.htm} a Java. Zatím je projekt pouze ve stádiu experimentální implementace\footnote{https://wiki.sdn.sap.com/wiki/display/Research/BlueRuby} a nehodí se pro reálné nasazení.

\subsubsection{Rubinius}
Zajimavý nápad napsat co nejvìt¹í èást ruby v samotném Ruby\footnote{http://rubini.us} - jedná se o pøepsaní nezbytnì nutných èástí interpretu do C++ a zbývajícího k\'{o}du do Ruby (napøíklad standartní tøídy - String, Array, Hash, ...). Intepret obsahuje just in time (JIT) kompilátor - parsovaný skript pøelo¾í prvnì do binárního k\'{o}du spustitelném na dané platformì a a¾ ten následnì spoustí. Tímto dosahuje zrychlení oproti MRI. Díky kompilaci do nativního k\'{o}du není zatí¾en GIL a umo¾nuje tedy plný paralelismus. V souèasné dobì je tento projekt stále ve vývoji - nìkolik aplikací v nìm ji¾ bì¾í, ale pro reálné nasazení není pøíli¹ vhodný.

\subsection{Mo¾nosti binárního roz¹íøení}
Distribuèní tarball MRI verze Ruby obsahuje také soubor README, kde je pìknì popsán rychlý úvod do psaní binárních roz¹íøení.

TODO: Hlubsi uvod

\subsubsection{Pøeklad roz¹íøení}
Binární roz¹íøení se pro MRI pøekládají pomocí pøíkazu \verb|make|, tak jak je tomu u vìt¹iny ostatních projektù v prostøedí Linuxu. Ov¹em na rozdíl od nich není pou¾ita sada programù autotools (skript ./configure pro generaci souboru Makefile). Makefile popisující jak se má roz¹íøení pøelo¾it a nainstalovat toti¾ vygeneruje samo Ruby - existuje modul \verb|mkmf| (MaKe MakeFile), pomocí jeho¾ metod programátor popí¹e na vysoké úrovní abstrakce, jak pøelo¾it jeho roz¹íøení a tento skript potom distribuuje spolu se zdrojovými k\'{o}dy. Celý sled pøíkazù pro pøeklad a instalaci je zobrazen na Obrázku \ref{ruby_rozsireni_fig1}.

\begin{figure}[tbh]
	\begin{verbatim}
	ruby extconf.rb
	make
	make install
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøeklad binárních roz¹íøení}
  \label{ruby_rozsireni_fig1}
\end{figure}

Modul \verb|mkmf| slou¾í hlavnì k nastavení dùle¾itých cest pro pøeklad automaticky a nezávisle na dané verzi èi distribuci operaèního systemu (cesta k hlavièkovým souborùm ruby, jeho knihovnám). Mimo této èinnosti modul nabízí metody, které umo¾nují podobné èinnosti jako skript ./configure\,--\,nalézat cesty k systémovým knihovnám, ovìøováním zda-li obsahují po¾adované symboly (funkce, promìné, ...) a dal¹í podobné funkce. Takto vytvoøený skript je samozøejmì plnìhodnotný program v Ruby. Lze tedy pou¾ít ve¹keré jeho mo¾nosti vèetnì pou¾ití dal¹ích knihoven. Napøíklad jde distribuovat pouze skript bez zdrojových k\'{o}dù, který si prvnì stáhnì nejnovìj¹í verzi projektu a a¾ poté bude pokraèovat ve své obvyklé èinnosti.

\subsubsection{VALUE}
\verb|VALUE| je datový typ, který v C reprezentuje Ruby objekt. V¹e je objekt a proto se tento datový typ pou¾ívá v¹ude\,--\,ka¾dá funkce volatelná z ruby vrací \verb|VALUE| jako svou návratovou hodnotu. Ve skuteènosti se jedná o pøejmenování datového typu \verb|unsigned long| obsahujícího adresu struktury reprezentující daný objekt. Vìt¹inou se tedy jedná o prostý ukazatel. Ov¹em ne ve v¹ech pøípadech. Interpret vyu¾ívá faktu, ¾e ukazatele jsou na platformì x86 v pamìti zarovnány - nejni¾¹í dva bity jsou pro ukazatele v¾dy nulové (platí pro 32 bitovou architekturu, pro 64 bitù se zarovnává na 8 bytù - tedy poslední ètyøi bity ukazatele jsou nulové).

Napøíklad objekty tøídy \verb|Fixnum| (reprezentující celá èísla) nemají svou strukturu jako ostatní objekty, ale jejich hodnota je zak\'{o}dována pøímo do promìné typu \verb|VALUE| tak, ¾e nultý bit (LSB, Least significant bit, nejménì významný bit) je nastaven na jednièku a ostatní bity jsou pou¾ity pro ulo¾ení vlastní hodnoty èísla. Tímto pøístupem se u¹etøí dereferencování ukazatele pøi práci s celými èísly. Samozøejmì zobrazitelný rozsah èísel je tímto pøístupem omezený na 31 bitù (èíslo je ulo¾eno v pamìti jako znaménkové v dopl\v{n}kovém k\'{o}du). Proto Ruby pro pøíli¹ velká celá èísla nabízí je¹tì tøídu \verb|Bignum|, její¾ hodnota není reprezentována pøímo v místì ukazatele a nabízí o dost vìt¹í rozsah.

Tato optimalizace není pou¾ita jen u celých èísel, ale také u singleton promìných významých a èasto pou¾ívaných tøíd. Singleton je oznaèení pro tøídu, která ma maximálnì jednu instanci v celém programu. V Ruby se jedná o instance tøíd \verb|TrueClass| (instance se jmenuje \verb|true|), \verb|FalseClass| (instancí je objekt \verb|false|) nebo \verb|NilClass| (instance je \verb|nil|, obdoba \verb|NULL| v jazyce C, ''prazdný`` nebo také ''¾ádný`` objekt). V¹echny tyto objekty nemají reprezentující strukturu, ale jejich obsah je pøímo zak\'{o}dován do typu \verb|VALUE| pro rychlej¹í interpretaci skriptu. Postup interpretu pøi interpretaci obsahu VALUE je zobrazený na obrázku \ref{fig_ruby_value_diagram}, který jsem pøevzal z èlánku\footnote{http://www.oreillynet.com/ruby/blog/2006/01/the\_ruby\_value\_1.htm} o tomto datovém typu.

\begin{figure}[ht]
  \centering
  \includegraphics[width=13.5cm,keepaspectratio]{./fig/ruby_value_diagram.png}
  \caption{Diagram pro reprezentaci hodnoty v promìné VALUE}
  \label{fig_ruby_value_diagram}
\end{figure}

\subsubsection{Symboly}
\verb|Symbol| je jeden z  datových typù Ruby, jeho¾ popis patøí spí¹e do sekce o vlastnostech, ale kvùli velké návaznosti na jeho vnitøní implementaci jsem se rozhodl zaøadit zmínku o nìm a¾ v této èásti. \verb|Symbol| je textový øetìzec podobný øetìzcùm tøídy \verb|String|, který se pro odli¹ení pí¹e s dvojteèkou pøed vlastním øetezcem. Pokud je symbol navíc slo¾en pouze z písmen, je mo¾né vynechat i jindy povinné uvozovky èi apostrofy (ukázky mo¾ností zápisu symbolu jsou na Obrázku \ref{ruby_symboly_fig1}).

\begin{figure}[tbh]
	\begin{verbatim}
	:ahoj.class # => Symbol
	:'ahoj'.class # => Symbol
	:'ahoj, tady jezisek'.class # => Symbol
	:'4'.class # => Symbol
	\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Rùzné zpùsoby zadání symbolu}
  \label{ruby_symboly_fig1}
\end{figure}

Symboly v Ruby mají nìkolik odli¹ných vlastností od tøídy \verb|String| - za prvé se jedná o objekty pouze pro ètení (nejde zmìnit hodnota, text symbolu) a druhý a podstatnìj¹í rozdíl je v rovnosti a identitì. V ukázce na Obrázku \ref{ruby_symboly_fig2} se provádí dvì dvojice porovnání na objektech tøíd \verb|String| a \verb|Symbol|. V prvním testu porovnávám objekty zda-li se rovnají (mají-li stejný obsah). Druhý test se ptá na ID (jednoznaèný identifikátor) objektu. Testuje tedy identitu objektu. Testy na rovnost samozøejmì v¾dy uspìjí, proto¾e jak symbol, tak øetìzec obsahují stejné hodnoty. Ov¹em test na identitu v pøípadì øetìzce sel¾e, proto¾e se jedná o dva rùzné objekty (vytvoøené interpretem pøi parsování zdrojového k\'{o}du programu). Symboly jsou si ov¹em identické - jedná se o jednu instanci. Tato dùle¾itá vlastnost symboly pøedurèuje k pou¾ítí na místech konstant nebo klíèù do asociativních polí. Symbol s daným textem existuje v pamìti maximalnì jednou, bez ohledu na poèet výskytù v programu, co¾ vede k ¹etøení pamìtí a zvý¹ení výkonu aplikace.

\begin{figure}[tbh]
	\begin{verbatim}
	'ahoj' == 'ahoj' # => true
	'ahoj'.object_id == 'ahoj'.object_id # => false

	:ahoj == :ahoj # => true
	:ahoj.object_id == :ahoj.object_id # => true
\end{verbatim} 
 	\vspace{-0.7cm}
  \caption{Porovnání a test identity symbolu a textového øetìzce}
  \label{ruby_symboly_fig2}
\end{figure}


Na úrovní zdrojových k\'{o}du MRI se jedná o tabulku jednoznaènì pøevádìjící textovou reprezentaci symbolu na datový typ \verb|ID| (co¾ je pøedefinovaný typ \verb|unsigned long|). Ve¹kerá porovnávání na rovnost symbolu jsou ve skuteènosti celoèíselná porovnání, která jsou rychlej¹í ne¾ øetìzcová, èím¾ se dosahuje optimalizace. Symbol je podobnì jako Fixnum pøímo zak\'{o}dován do typu \verb|VALUE|, nedochazí zde tedy k dereferencování ukazatele pro získaní èíselné hodnoty.

Java obsahuje velice obdobný mechanismus pomocí volání \verb|String.intern()|, C++ nic jako symbol bohu¾el nezná.


\subsubsection{API}
Seznam dostupných funkcí, které jsou v binárních roz¹íøení k dispozici zde neopisuji, proto¾e je lze nalézt v pøehledné dokumentaci.

\subsubsection{TODO}
OPTIONAL TODO: Popis toho co to je EigenClass

OPTIONAL TODO: Zapouzrení a moznosti jeho obejiti - private je jen doporuceni na implicitni save, objekt\#instance\_eval

\section{Expertní systémy}
TODO: Popsat co jsou vlastne expertni systemy, jak se s nimi pracuje, cim se lisi od ostatnich, trochu historie.

\subsection{Clips}
TODO: Popsat historii CLIPS, co to je v dnesni dobe. Prakticke ukazky jak se v clips pracuje. Zahrnout kapitolu o rozsiritelnosti.

\subsubsection{Reetùv algoritmus}
Popsat jak funguje.

%=========================================================================
\chapter{Zpùsoby tvorby roz¹íøení}
%=========================================================================

Binární roz¹íøení skriptovacího jazyka je dynamická knihovna napsaná vìt¹inou ve stejném jazyce jako cílový interpret. V pøípadì MRI verze Ruby jsou roz¹íøení psaná v C. Lze je psát i v C++, ale kvùli odli¹ným pøekladovým a linkovacím konvencím se jedná o vyjímeèné pøípady. Tyto knihovny pøi naèítání zpravidla zaregistrují v interpretu nové tøídy a jejich metody namapují na své vlastní funkce. Tímto postupem se roz¹íøí mno¾ina dostupných tøíd a funkcionality pro programy.

Dùvodù proè napsat binární roz¹íøení místo nativního kódu se dá najit nìkolik. Prvním a asi i nejpodstatnìj¹ím je rychlost. Programy napsané v C budou provádìny rychleji ne¾ jejich skriptovací ekvivalenty a proto zapouzdøení nejnároènìj¹ího kódu z Ruby do C pøíná¹í výkonostní vylep¹ení. V rámci standadních Ruby tøíd je k dispozici modul pro práci s XML jménem \verb|REXML| napsaný v èistém Ruby. Existuje k nìmu nìkolik alternativ, z nih¾ napøíklad libxml-ruby\footnote{http://libxml.rubyforge.org/}, co¾ je binární roz¹íøení zapouzdøující práci s XML knihovnou libxml\footnote{http://xmlsoft.org/}, je podle webových stránek projektu a¾ o dva øády rychlej¹í.

Druhým dùvodem mù¾e být nutnost. Standardní knihovny nemùsí zpøístup\v{n}ovat v¹echny po¾adované nízko úrov\v{n}ové mo¾nosti operaèního systému. Programátor je tak nucen napsat si miniroz¹íøení, které právì jím po¾adované vlastnosti zpøístupní.

Poslední dùvod je pohodlnost. Proè pøepisovat celou ji¾ napsanou a navíc i odladìnou knihovnu do jiného jazyka, kdy¾ staèí zpøístupnít pouze její API. Velice dobrým pøíkladem takovýchto knihoven jsou rozhraní pro GUI frameworky GTK\footnote{http://ruby-gnome2.sourceforge.jp/} a QT\footnote{http://www.darshancomputing.com/qt4-qtruby-tutorial/}.

Libovolnou knihovnu napsanou v C jako roz¹íøení pro skriptovací jazyk nelze pou¾ít pøímo, proto¾e by interpret nevìdel, jak s ní má zacházat. Je potøeba napsat rozhraní mezi touto knihovnou a interpretem, které je zodpovìdné za dvì dùle¾ité èinnosti: (1) musí v interpretu registrovat nabízené funkce a tøídy knihovny, (2) musí poskytovat pøekladovou úrovìn pro odli¹né volací konvence knihovny a interpretu. MRI napøíklad vy¾aduje u v¹ech funkcí volatelných z ruby, aby pøijímaly a vracely pouze datový typ \verb|VALUE|. Bì¾ná knihovna nic o specifickém datovém typu interpretu neví a u¾ vùbec netu¹í jak tøídu \verb|String| pøevést na C reprezentaci øetìzce. Za tyto typové pøevody je takté¾ odpovìdná pøekladová úrove\v{n}.

Existují v základì dva odli¹né postupy k tvorbì binarních roz¹íøení skriptovacích jazykù, automatický a manuální. V následujících sekcích se jim budu detailnìji vìnovat.

\section{Automatický postup}
Pomocí speciálních nástrojù lze vrstvu mezi knihovnou a interpretem nechat vygenerovat automaticky. Pøíkladem mù¾e být projekt SWIG\footnote{http://www.swig.org/} (Simplified Wrapper and Interface Generator) slou¾ící pro automatickou tvorbu roz¹íøení pro knihovny napsané v C nebo C++. Seznam podporovaných jazykù je uctyhodný a mimo jiné zahrnuje známé jazyky jako Python, Perl, PHP nebo právì Ruby.

Pou¾ití podobných nástrojù je velice snádné. Vìt¹inou je bez slo¾ité a zdlouhavé konfigurace staèí spustit nad hlavièkovými soubory zpøístup\v{n}ované knihovny. Jako výstup vygenerují rozhraní, zdrojový text v jazyce C nebo C++, který staèí u¾ jen pøelo¾it a poté nahrát v rámci programu vykonávaného v interpretu.

Vygenerovné rozhraní zpravidla obsahuje pro ka¾dou nalezenou funkci knihovny jednu novì vygenerovanou funkci, která slou¾í jako pøekladový obal. Vezme parametry pøedané interpretem a pøelo¾í datové typy do typù knihovny. Pro MRI je tøeba pøevést pøedané objekty do jejich C reprezentací. Tedy pøevést objekt typu \verb|Fixnum| na \verb|integer|, \verb|String| na \verb|char *|, atd.. Poté zavolat obalovanou funkci knihovny a nakonec pøevést její návratovou hodnotu zpìt na Ruby objekt a vrátit ji interpretu. Rozhraní navíc obsahují jednu inicializaèní funkci, která v¹echny vygenerované obalovací funkce zaregistruje aby byly v interpretu k dispozici.

Takto vygenerované rozhraní je velice pøímoèaré a programátor ma minimální kontrolu nad jeho výslednou podobou. Zpøístup\v{n}uje v¹echny funkce knihovny pro jejich volání ze skriptovacího jazyka se zachováním sémantiky jejich argumentù bez jakékoliv vý¹¹í abstrakce. Navíc zde mù¾e být problém se slo¾itými vnitøními datovými typy, které se pou¾ívají i vnì knihovny.

\section{Manuální postup}
Manuálním napsáním spojovací vrstvy získá prográmátor plnou kontrolu nad výsledkem. Jako jednu z hlavních výhod vidím mo¾nost vytvoøit z vnitøních struktur pou¾ivaných i vnì knihovny tøídy a z funkcí nad nimi operujícími metody této tøídy. Výsledkem je krásnì objektové chování, jak jsou programátoøi v Ruby zvyklí na rozdíl od pouhého procedurálního zpøístup\v{n}ení v¹ech funkcí. Navíc není problém zapouzdøovanou knihovnu tøeba roz¹íøit o dal¹í funkcionalitu, která se u¾ ov¹em bude odehrávát pouze na úrovni Ruby.

Na druhou stranu má tento postup oproti automatickému pøístupu jednu obrovskou nevýhodu - èas programátora. Ten mùsí nastudovat rozhraní knihovny, navrhnout jeho vhodné zapouzdøení a nakonec i celé rozhraní napsat. Díky èasové nároènosti se plnì manuální pøístup v praxi pou¾ívá pouze zøídka a pokud je snaha knihovnu je¹tì zapouzdøit na vy¹¹í úrovni, polo¾ením do objektù napøíklad, tak se spí¹e pou¾ívá kombinace obou pøístupù. Automaticky se vytvoøí rozhraní knihovny pøístupné ve skriptovacím jazyce a a¾ toto rozhraní se následnì zapouzdøí do objektù a dal¹ích specifických jazykových konstrukcí, které v C nebo C++ nejsou známy.

%=========================================================================
\chapter{Knihovna rbClips}
%=========================================================================
V této kapitole se ji¾ dùkladnì budu vìnovat své vlastní prácí - knihovnì rbClips. Postupnì v následujícíh podkapitolách popí¹i její návrh, nìkteré zajimavé implementaèní detaily a samozøejmì nevynechám shrnutý popis aplikaèního rozhraní. \'{U}plné detaily rozhraní u¾ ov¹em nechám do programové dokumentace. V závìru kapitoly je uveden praktický pøíklad pou¾ítí knihovny.

\section{Návrh}
Velice jsem rozmý¹lel jak výsledné binární roz¹íøení vytvoøit. Nejjednodu¹¹í pøístup automatického vytvoøení celého rozhraní by zachoval dostupné funkce CLIPS i s jejich parametry. U¾ivatel knihovny by byl nucen uèit use navíc je¹tì syntaxi u¾ivatelského rozhraní CLIPS, co¾ je velice ne¾ádoucí. V úvodních verzích návrhu jsem se proto pøiklonil spí¹e ke kombinovanému pøístupu. Nad automaticky vygenerovaným rozhraním jsem napsal vý¹¹í zapouzdøovací lgiku, která celé procedurální chování zapouzdøila do objektù. S tímto pøístupem dokonce vzniklo nìkolik funkèních prototypù knihovny na prezentaci, ¾e je to takto mù¾e fungovat (tkz. ''proof of concept``). Prototypy sice fungovaly, ov¹em kvùli neustálému pøevádìní v¹ech datových typù z Ruby objktù do C a zpìt pøi ka¾dé operaci trpìly slab¹ím výkonem. Napøiklad i jinak velice rychlá práce s ukazateli jazyka C byla zpomenalena neustálimi konverzemi do objektù, které byly pøedany do vy¹¹ích vrstev ke zpracování, a následnému pøevedení zpìt na ukazatele, aby se na jejich základì provedla v CLIPS urèitá operace (napøíklad nalezení urèitého faktu).

Proto jsem se nakonec rozhodl celé rozhraní napsat v jazyce C a dodávat jako èistì binární roz¹íøení. Po dùkladném pøeètìní dokumentace k Ruby jsem navíc zjistil, ¾e umo¾nuje do objektù ulo¾it i ukazatel na libovoulnou strukturu. O tu se navíc stará sám interpret. Garbage collector pøed uvolnìním objektu obsahujícího ukazatel zavolá nejprve registrovanou uvol\v{n}ovací funkci na tento ulo¾ený ukazatel a a¾ následnì objekt opravdu odstraní. Nejèastìji je registrováná funkce \verb|free()|, ale v pøípadì potøeby pro slo¾itìj¹í struktury lze zaregistrovat zcela libovolnou funkci (pøijímací právì jeden parametr typu \verb|void *|). Ta mù¾e strukturu postupnì uvolnit tak, aby nedo¹lo k ¾ádným únikùm pamìti.

Do objektù ukládám vlastní struktury, které obsáhují alespo\v{n} jednu promìnou. Tou je ukazatel \verb|void *| ukazující na rùzné struktury v CLIPS prostøedí. Napøíklad Ruby objekt reprezentující fakt má takto ulo¾en ukazatel na jeho strukturu v CLIPS. Tím padém mám k dispozici rychlé spojení mezi Ruby objektem a jeho CLIPS reprezentací. Nemusím poka¾dé popisovanou entitu vyhledávat a operace v¹echny operace jsou podstatnì rychlej¹í.

Samotné aplikaèní rozhraní, které je pøístupné u¾ivateli (API), jsem navrhnul po vzoru open source knihovny ActiveRecords (AR). Projekt AR je v Ruby svìtì hlavnì spojován s webovým frameworkem Ruby on Rails a pou¾ívá se k zapouzdøení jazyka SQL do objektù. Stejnì jako AR odsti\v{n}uje programátora od nutnosti znát SQL, tak i rbClips odstin\v{n}uje programátora od nutnosti znát u¾ivatelské rozhraní CLIPS. Ve¹kerá funkcionalita je zapouzdøena do objektù a ovládá se pomocí method tìchto objektù. Hlavní dùvod proè jsem rozhraní navrhl po vzoru AR je jeho velká roz¹íøenost. Jakykoliv programátor, který alespo\v{n} èásteèné zná rozhraní AR se v rbClips velice rychle zorientuje a nebude mít pøíli¹ velké problémy mou knihovnu zaèít pou¾ívat.

Inspirace AR se projevila v urèitých vzorech, které jsou shodné napøíè celým API. Mimo vyjímek zmínìných u popisu konkretních tøíd ní¾e obsahují v¹echny tøídy spoleènou podmno¾inu metod zobrazenou na obrázku \ref{common_methods}. Entita zastupuje libovolnou hlavní tøídu knihovny rbClips, dvojznak \verb|::| pøíslu¹í tøídní metodì, zatímco znak \verb|#| patøí instanèní metodì. Inspirace AR není vidìt jen u tìchto spoleèných metod, ale také v chování celé knihovny. Napøíklad vytvoøení instance tøídy Fact, Rule nebo Template automaticky nevytvoøí odpovídající novou entitu i v prostøedí CLIPS. K vytvoøení (ulo¾ení) entity v prostøedí CLIPS dojde a¾ v okam¾iku zavoolání metody \verb|save|. Velice podobnì to funguje i s aktualizací entit, ve¹keré zmìny je potøeba potvrdit opìtovným voláním metody \verb|save|, jinak se zmìny v prostøedí CLIPS nikdy neobjeví.

\begin{figure}[tbh]
  \textbf{Entita\#save} Ulo¾í nebo aktualizuje popisovanou entitu v prostøedí CLIPS.

  \textbf{Entita\#saved?} Vrátí boolenovou hodnotu zda-li je daná entita pøítomna v prostøedí CLIPS. 

  \textbf{Entita\#destroy!} Vyma¾e danou entitu z CLIPS prostøedí.

  \textbf{Entita\#update} Aktualizuje v¹echny atributy Ruby objektu podle jejich aktuální hodnoty v prostøedí CLIPS. Pro správnou funkci ji¾ daná entita mùsí v CLIPS existovat.

  \textbf{Entita::all} Vrátí pole v¹ech existujících entit daného typu.

  \textbf{Entita::load} Vrátí jednu nebo více entit dle pøedaných kritérii. Jako parametr bere v pøípadì tøíd \verb|Template| a \verb|Rule| jméno hledané entity, tedy parametr tøídy \verb|String| a vrací právì jednu nalezenou instance popøípadnì \verb|nil|. Pro tøídu Fact akceptuje o dost ¹ir¹í mo¾ností argumentù, které zde nebudu zbyteènì opisovat z programové dokumentace.
  
  \caption{Spoleèná podmno¾ina metod vìt¹iny tøíd knihovny rbClips.}
  \label{common_methods}
\end{figure}

\section{Výhody pou¾ití rbClips}
Výhody, které pou¾ítí rbClips nabízí oproti pøímemù pou¾ití CLIPS, jsou rùznì rozprostøeny po celém tomto textu. Pro pøehlednost jsem se rozhodl je zde dohromady shrnout a zopakovat, aby je ètenáø mìl k dispozici na jednom místì a nemusel slo¾itì prohledávat celý text.

\textbf{Zapouzdøení procedurálního chování.} Manuální pøístup k tvorbì zpøístup\v{n}ovacího binárního roz¹íøení mi umo¾nil zapouzdøit jednotlivé skupiny funkcí do tøíd. Napøíklad v¹echny funkce pracující s fakty jsou a\v{t} u¾ pøímo èi nepøímo volány pomocí method tøídy Fact. Samotná tøída navíc celé rozhraní pøispùsobuje objektovému návrhu a nepsaným konvecím jazyka Ruby. Programátor pou¾ivající rbClips si vùbec nemùsí být vìdom, ¾e na ní¾¹í úrovni se pou¾ívá pouze procedurální knihovna napsaná v jazyce C.

\textbf{Zapouzdøení syntaxe CLIPS.} Zapouzdøení celého rozhraní knihovny rbClips do objektù umo¾nilo schovat u¾ivatelské rozhraní CLIPS. Programátor se tak nemusí uèit dal¹í jazyk, navíc od Ruby velice odli¹ný, kterým by ovládal prostøedí CLIPS. Nìkteré ménì vyu¾ivané konstrukce CLIPS nejsou bohu¾el v rbClips pøímo podporovány, a proto jsem pøidal mo¾nost vkládat a vykonávat validní úryvky CLIPS k\'{o}du pøímo. 

\textbf{Zpìtné volání Ruby method.} Knihovna obsahuje mo¾nost jako akci pro pravidla (konsekvent) nastavit metodu libovolného objektu Ruby. Ta se po aktivaci pravidla zavolá. Do takto volané metody lze pøedat libovolné parametry a to nejen ty známé v dobì tvorby pravidla, ale tøeba i ty které vedly k aktivaci pravidla.

\textbf{Vyu¾itý v¹ech dostupných Ruby knihoven.} Ve výsledém expertním systému jeho¾ základem bude knihovna rbClips, lze vyu¾ívat naprosto libovolnou ji¾ existující knihovnu Ruby. Díky mo¾nosti volání libovolné metody v rámci aktivace pravidel lze napøíklad v dobì vyhodnocení pravidla pou¹tet dotazy v relaèních databázích nebo spou¹tet externí utility.

\section{Pøeklad}
Zdrojové k\'{o}dy knihovny rbClips jsou k dispozici na pøilo¾eném CD. Na tém¾e CD je k dispozici i celý git repozitáø. \u{C}tenáø má tedy pøístup k celé historii projektu, ne jen k jeho odevzdané verzi. Vývoj knihovny dnem odevzdání bakaláøské práce navíc nekonèí a nejaktuálnìj¹í verzi lze stáhnout z veøejného git repozitáøe serveru Github (potøebný pøíkaz je na obrázku \ref{github_download}).

Knihovna má dvì hlavní závislosti - CLIPS a Ruby. CLIPS je mo¾nost stáhnout z oficiálních stránek projektu a to zvlá¹\v{t} balíèek se zdrojovými k\'{o}dy a s rùznymi makefile soubory. Makefile soubor pro pøeklad knihovny bohu¾el obsahuje chybu. Chybí v nìm flag \verb|-fPIC|, bez kterého se nedá dynamická knihovna vytvoøit. Proto jsem se rozhodl umístit zdrojové k\'{o}dy CLIPS, oproti kterým je má bakaláøská práce vytvoøena a otestována, pøímo do svého repositáøe. Odpadá tedy nutnost ruèního stáhohvání CLIPS.

Druhá hlavní závislost\,--\,Ruby\,--\,ji¾ v mém repozitaøi z dùvodu pøítomnosti ve vìt¹inì distribucí a velice aktivnímu vývoji není pøítomna. Pro pøeklad je potøeba mít nainstalován nejen samotný interpret, ale i jeho pøípadné devel balíèky. Po¾adovaná verze je 1.9.x, dnes ji¾ pouze udr¾ovaná vìtev 1.8 není rbClips podporována a knihovna nepùjde s touto verzí pøelo¾it.

Z obvyklých závislostí je potøeba mít prostøedí pro pøeklad, tedy hlavnì pøekladaè gcc. Z rodiny nástroju autotools je potøeba pouze balíèek s programem make. Ostatní nejsou potøeba, proto¾e Makefile pro pøeklad binárního roz¹íøení vytvoøí Ruby skript, který je pro tyto úèely dodán. V koøenové slo¾ce projektu je ji¾ vytvoøen hlavní soubor Makefile, který obsahuje v¹echny èásti pøekladu pohromadì. Pro samotný pøeklad tedy staèí spustit program make v koøenové slo¾ce knihovny. 

Jako první se pøelo¾í zahrnutá verze CLIPS a a¾ následní vlastní knihovna rbClips. V poslední fázi pøekladu se spustí automatické testy pro ovìøení správnosti a funkènosti pøekladu.

\begin{figure}[tbh]
	\begin{verbatim}
git clone git://github.com/jarcec/rbclips.git
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Sta¾ení nejnovìj¹í verze knihovny rbClips ze serveru Github.}
  \label{github_download}
\end{figure}

\section{Aplikaèní rozhraní knihovny}
Jak jsem ji¾ zmínil celé aplikaèní rozhraní je navr¾eno dle vzoru ActiveRecords, podle kterého sdílí základní my¹lenky a principy pou¾ívání. Celá knihovna je zapouzdøena v jednom Ruby modulu jménem \verb|Clips|. Ten obsahuje pìt hlavních tøíd - \verb|Fact|, \verb|Template|, \verb|Rule|, \verb|Environment|, \verb|Constraint| - které popisují pøíslu¹né entity v CLIPS a zapouzdøují celou práci s nimi. Dále obsahuje nìkolik pomocných tøíd, které u¾ivatel není oprávnìn vytváøet pøímo. Dostává je jako ji¾ vytvoøené objekty do konfiguraèních blokù hlavních tøíd. Tyto pomocné tøídy budou upøesnìny dále v textu v popisu jednotlivých hlavních tøíd, kde jsou pou¾ívány. Nakonec obsahuje je¹te module \verb|Base| slou¾ící pro volání dùle¾itých funkcí CLIPS, které nejsou souèástí jiných velkých entit. 

\subsection{Modul Base}
CLIPS je celé prostøedí pro tvorbu expertních systémù, nikoliv jen knihovna pro tvorbu faktù, pravidel a dal¹ích vìt¹ích entit. Proto obsahuje také velké mno¾ství rùzných dopl\v{n}kových funkcí, které prostøedí umo¾nují ovládat. Právì pro tyto funkce existuje modul Base, kde jsou pohromadì metody, které se nedotýkají ¾ádného velkého celku CLIPS, ale nelze si bez nich výsledný expertní systém pøedstavit. Dále uvedu krátky seznam nejdùle¾itìj¹ích metod:

\textbf{run(FixNum = 0)} Metoda run slou¾í k zahájení aplikace pravidel. Bì¾ný postup spu¹tìní programu v CLIPS sestává z vytvoøení mno¾iny pravidel a prvotních faktù a následného spu¹tìní vlastního enginu pro jejich zpracování. Knihovna rbClips na tomto pøístupu nic nezmìnila proto se do zavolání metody run ¾ádná pravidla neaplikují. Pro zamezení pøípadnému nekoneènému cyklu slou¾í volitelný argument urèující maximální poèet pravidel, která se smí aplikovat.

\textbf{insert\_command(String)} Knihovna rbClips zapouzdøuje nejpou¾ívanìj¹í èásti CLIPS, bohu¾el ov¹em ne ve¹kerou mo¾nou funkcionalitu. Kvùli absenci 100\% pokrytí jsem vytvoøit metodu \verb|insert\_command|. Na vstupu dostává jako parametr jeden validní pøíkaz CLIPS, který následnì provede. Kvùlí chování funkcí, které jsou v prostøedí CLIPS nakonec zavolány, je pro správnu funkènost nutné, aby pøedaný øetezec obsahoval maximálnì jeden pøíkaz. V pøípadì, ¾e jich bude obsahovat více, tak se provede pouze první z nich. Navíc se do Ruby vrátí informace, ¾e v¹e probìhlo v poøádku, co¾ mù¾e být velice matoucí.

\subsection{Tøída Environment}
CLIPS umo¾nuje soubì¾ný bìh nìkolika prostøedí, které jsou na sobì navzájem nezávislé. Ka¾dé prostøedí má svou vlastní mno¾inu pravidel, faktù a pro spu¹tìní rozhodovacího enginu musí pro ka¾dé prostøedí být spu¹tìna methoda \verb|run|. Souèasná implementace prostøedí v rbClips je napsána mírnì neobjektovì, proto¾e pouze následuje mo¾nosti, které ji CLIPS nabízí. V jeden okam¾ik mù¾e být aktivní pouze jedno prostøedí a to i v pøípadì více vláknové aplikace. 

Navíc je potøeba u vícevláknových aplikace dávat pozor na potencionálnì nebezpeèné volání \verb|Environment::new|. CLIPS novì vytvoøené prostøedí rovnou nastaví jako aktuální, co¾ poru¹uje konvence rbClips. Prostøedí se stává aktivní a¾ po zavolání metody \verb|set\_current| (obdoba metody \verb|save| z ostatních hlavních tøíd). Volání konstruktoru tøídy tedy vytvoøí nové prostøedí a poté pøepne zpìt do starého prostøedí. Toto pøehazování je nebezpeèné právì ve více vláknových aplikacích, kde mohou nastat te¾ko odhalitelné race conditions. Napøíklad se ukládaná pravidla èi fakta mohou ulo¾it do zdánlivì náhodnì jiných prostøedí. Z tohoto dùvodu doporuèuji vytvoøit v¹echna potøebná prostøedí je¹tì pøed samotným vytvoøením vláken.

\begin{figure}[tbh]
  \begin{verbatim}
    include Clips
    env = Environment.new # Vytvori nove prostredi
    cur = Environment.current # Vrati aktualni prostredi
    env.set_current # Nastavi aktualni prostredi
  \end{verbatim}
  \vspace{-0.7cm}
  \caption{Pøíklad pou¾ití tøídy Environment.}
  \label{rbclips_example_environment}
\end{figure}

\subsection{Tøída Constraint}
Na rozdíl od Ruby v CLIPS existuje více datových typù ne¾ pouhý objekt. Existují zde datová primitiva známá z ostatních programovacích jazykù jako napøíklad celá èísla, desetinná èísla èi øetìzce. Ve výchozím stavu lze do slotu neseøazených faktù ulo¾it libovolnou hodnotu. Popøípadnì mno¾inu hodnot, jedná-li se o multislot. Z logického hlediska by ov¹em napøíklad do slotu vìk, který jak u¾ z názvu vyplývá udr¾uje vìk osoby, nemìlo pøílis smysl ukládat øetezec. Z toho dùvodu zavádí CLIPS mo¾nosti omezeni (constraints). V ¹ablonách lze pro libovolný nastavit také jeho omezení, napøíklad seznam akceptovaných datových typù. Mimo toho lze je¹tì omezit v pøípadì multislotù minimální a maximální poèet prvkù, pro èíselné sloty dolní i horní hranici mo¾né ulo¾ené hodnoty nebo pro napodobéní výètového typu lze pøímo vyjmenovat v¹echny hodnoty, kterých smí daný slot nabývat.

Uvnitø CLIPS bohu¾el neexistuje mo¾nost jak mno¾inu omezení ulo¾it jako samostatnou entitnu. Omezení je v¾dy ulo¾eno pouze v rámci jednotlivých slotù vytváøených ¹ablon. Z tohoto dùvodu objekty tøídy \verb|Constraint| nemají metodu \verb|save| a nejdou tedy ani ulo¾it. Existují pouze na úrovni interpretu Ruby. Pokud programátor nastaví nìjakému slotu omezení, vezme se jeho aktuální stav a ten se pou¾ije. Pokud je tento \verb|Constraint| objekt posléze zmìnìn, tak se zmeny ji¾ zpìtnì nepromítnou do v¹ech míst, kde byl pou¾it. Proto doporuèuji vytvoøit v¹echny objekty popisující omezení na jednou na zaèátku programu a je¹tì pøed tvorbou ¹ablon a dále je pokud mo¾no ji¾ nemìnit.

Vytvoøení omezení je snadné, konstruktor akceptuje jako parametr jedno asociativní pole se ètyømi mo¾nými klíèi. První mo¾nost klíè \verb|:type| jako hodnotu akceptuje jeden nebo pole mo¾ných typù. Typy jsou reprezentováný symboly a smí nabývat hodnot \verb|:symbol|, \verb|:string|, \verb|:lexeme|, \verb|:integer|, \verb|:float|, \verb|:number|, \verb|:instance_name|, \verb|:instance_address|, \verb|:instance|, \verb|:external_address|, \verb|:fact_address| popøípadnì hodnoty \verb|:any| reprezentující jakýkoliv datový typ (implicitní hodnota). Druhý mo¾ný klíè je \verb|:values| akceptující jednu èi pole v¹ech rùzných hodnot, kterých slot s tímto omezení smí nabývat. Poslední dva klíèe \verb|:range| a \verb|:cardinatily| akceptují Ruby objekt interval. Klíè \verb|:cardinality| omezuje poèet mo¾ných hodnot v multislotech, zatímco \verb|:range| omezuje mo¾né velikosti ulo¾itelných èísel.

\begin{figure}[tbh]
  \begin{verbatim}
    a = Constraint.new :type => [:string, :lexeme]
    b = Constraint.new :type => :integer, :range => 3..13
  \end{verbatim}
  \vspace{-0.7cm}
  \caption{Pøíklad pou¾ití tøídy Constraint.}
  \label{rbclips_example_constraint}
\end{figure}

\subsection{Tøída Template}
V CLIPS lze mimo obvyklých seøazených faktù, které obsahují neorganizovaný seznam atributù, také takzvané seøazené fakta. Ty bych mohl pøirovnat ke strukturním promìnám v jazyce C. Struktura má svuj pøedpis, tedy jméno a seznam atributù, které obsahuje. Velice podobnì je tomu i v CLIPS, pøedpis pro tvorbu seøazených faktù se jmenuje ¹ablona. V rbClips se celá práce s ¹ablonami zapouzdøuje do tøídy \verb|Template|. Jednotlivým atributùm se potom øíka sloty. Ka¾dý slot musí mít v rámci jedné ¹ablony své unikátní jméno. Navíc mu lze volitelnì nastavit i \verb|Contrait| objekt, kterým lze omezit mo¾né ulo¾itelné hodnoty. 

Výhoda pou¾ití seøazeného faktu nad neseøazeným je v mo¾nosti ulo¾it do faktu i èást sémantiky. Na obrázku \ref{rbclips_template} je zobrazen seøazený fakt popisující èlovìka a poté i jeho neseøazená varianta. U seøazeného faktu musí programátor pøesnì vìdet na jaké pozici je ulo¾ena hledaná hodnota (napøíklad vìk). Navíc mu nic nebraní si do jednotlivých pozic ulo¾it jakoukoliv jinou hodnotu a do polo¾ky pohlaví tak napøíklad ulo¾it nesmyslnou hodnotu $q33$. Naproti tomu neseøazený fakt ji¾ obsahuje èást semantiky. Slot vìk v¾dy bude obsahovat vìk, jeliko¾ je nadefinován jako èíselný. Pohlaví bude v¾dy nabývat pouze hodnot ''mu¾`` nebo ''¾ena``, jeliko¾ je v definici slotu uveden pøesný výèet mo¾ných hodnot. Navíc jak lze mírnì odvodit z úkazky, neseøazený fakt se porovnává slot po slotu a  vùbec nezále¾í na uvedeném poøadí jednotlivých slotù.

\begin{figure}[tbh]
	\begin{verbatim}
(serazeny-clovek "Jarek Cecho" muz 22)
(neserazeny-clovek (jmeno "Jarek Cecho") (vek 22) (pohlavi muz))
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Rozdíl zápisu seøazeného a neseøazeného faktu.}
  \label{rbclips_template}
\end{figure}

Velice zajimavá je vnitøní implementace rozdílu seøazených a neseøazených faktù a ¹ablon na úrovní zdrojových k\'{o}dù CLIPS v jazyce C. Ve skuteènosti toti¾ na této nejni¾¹í úrovni vytváøí CLIPS pro seøazené fakty ¹ablony s jedním multislotem jménem \verb|implied| a v¹echny atributy ukládá dovnitø. Tuto zkuteènost si samozdøejmì poznaèí a odstíní tak u¾ivatele od nutnosti znát vnitøní implementaci. Toto chování usnadnilo vnitøní implementaci tøídy Fact, jak blí¾e popí¹i v následujících odstavcích. Pøíná¹í s sebou ov¹em i jeden problém, jména ¹ablon a skupiny seøazených faktù jsou bráná se spoleèné mno¾iny. A vzhledem k tomu, ¾e musí být unikátní, tak nelze mít ¹ablonu a skupinu seøazených faktù se stejným jménem. Proto v uvedené ukazce se ¹ablona jmenuje \verb|neserazeny-clovek| a skupina seøazených faktù \verb|serazeny-clovek|.

Vytvoøit ¹ablonu lze dvìmi základními postupy. Konstruktor akceptuje bu\v{d} konfiguraèní asociativní pole nebo jméno ¹ablony s konfiguraèním blokem. V pøípadì konfigurace u¾itím asociativního pole, musí toto pole obsahovat povinnì dva klíèe - \verb|:name| a \verb|:slots|. Klíè \verb|:name| slou¾í pro zadání jména ¹ablony, které musí být v daném prostøedí unikátní. Druhý po¾adovaný klíè \verb|:slots| slou¾í jako seznam slotù vytváøené ¹ablony. Akceptuje jako hodnotu bu\v{d} pole objektù tøídy \verb|String| nebo \verb|Symbol|, které bude reprezentováno jako jména jednotlivých slotù. V pøípadì kdy u¾ivatel potøebuje slotùm zmìnit výchozí chování je pro nìj nachystána druhá varianta klíèe \verb|:slots|, která pøijimá dal¹í (ji¾ tedy vnoøené) asociativní pole. Klièi tohoto vnoøeného pole jsou jména slotù pøièem¾ hodnotami je v poøadí ji¾ tøetí asociativní pole, které obsahuje seznam atributù daného slotu. Attributy slotù existují dva, \verb|:multislot| povolující ulo¾ení více hodnot v rámci jednoho slotu a \verb|:default| obsahující výchozí hodnotu (implicitnì \verb|nil|).

Zápis u¾ivající postupnì tøi vnoøená asociativní pole není zrovna pro èlovìka pøehledný a proto existuje druhá o dost èitelnìj¹í varianta volání konstruktoru u¾itím bloku. Konfiguraèní blok bude zavolán s jednou promìnou tøídy \verb|TemplateCreator|, která má metodu \verb|slot| slou¾ící pro vytvoøení nového slotu. Jméno slotu je pøedání jako první argument. Volitelnì lze jako druhý argument pøedat asociativní pole popisující atributy slotu (tedy to samé asociativní pole, které se pøedává jako druhé vnoøené pøí první variantì volání konstuktoru).

\begin{figure}[tbh]
  \begin{verbatim}
Template.new :name => 'animal', :slots => %w(name age race)
Template.new 'animal' do |t|
  t.slot :name
  t.slot :age
  t.slot :race
end
  \end{verbatim}
  \vspace{-0.7cm}
  \caption{Dvì mo¾nosti tvorby stejné ¹ablony.}
  \label{rbclips_example_template}
\end{figure}

\subsection{Tøída Fact}
Jak ji¾ bylo zmíno CLIPS rozli¹ují dva typy faktù - seøazené a neseøazené. Díky velice podobné vnitøní implementaci obou druhù faktù v CLIPS, jsem je oba zapouzdøil do jediné Ruby tøídy jménem \verb|Fact|. Vìt¹ína rozhraní této tøídy je shodná pro oba typy faktù, ale samozdøejmì existují èásti, ve kterých se API li¹í.

Podobnì jako celé rozhraní rbClips i mìnìní obsahu faktù je navr¾eno po vzoru ActiveRecords. Programátora AR tedy nepøekvapí, ¾e zmìny faktù se neprojeví v CLIPS okam¾itì, ale jsou jen lokálnì ulo¾eny v instance tøídy. A¾ po zavolání metody \verb|save| se v¹e ulo¾í. Bohu¾el CLIPS se ke zmìnì faktu chová velice neprakticky - místo zmìnìní jednotlivých atributù se aktualizovaný fakt prvnì vyma¾e a poté se vlo¾í nový s ji¾ aktualizovanými hodnotami. Samozdøejmì toto probíhá jako jedna atomická operace - tedy není stav, kdy by zbytek systému mohl postøehnout, ¾e jeden fakt byl vymazán a nový je¹tì nevlo¾en. Pro rbClips to ov¹em znamená obrovský problém. Instance tøídy si udr¾uje ukazatel na strukturu faktu v CLIPS a aktualizací se tento ukazatel stává neplatným. Objekt je tedy po aktualizaci ji¾ vlastnì neulo¾ený (jeho vnitrní ukazatel neukazuje na platný fakt). Tento neduh se mi nepodaøilo opravit tak, abych nerozbil jinou ji¾ napsanou funkcionalitu, pøípadnì budoucí plány s roz¹íøením podpory pro vícevláknové aplikace. Proto je na u¾ivateli rbClips, aby zajistil, ¾e aktualizaci provede a¾ v momentì, kdy u¾ daný fakt nebude potøeba nadále mìnit. Ze zku¹enosti z pou¾ívání AR, které je pøedlohou rozhraní, si myslim, ¾e to nebude a¾ takový problém dodr¾et.

\subsubsection{Metody pøístupné pro seøazený fakt}
Na následujících pár øádcích bych rád popsal metody specifické pro seøazený fakt. Rozhraní tøídy Fact je ov¹em optimalizované hlavnì pro neseøazené fakty, proto¾e ty obsahují více mo¾ností pro èistèí návrh rozhraní. Z tohoto dùvodu bych doporuèil pou¾ívat radìji neseøazenou variantu faktu.

U seøazené varianty slotu si rbClips stejnì jako CLIPS samy uchovává pole atributù, které vrací metoda \verb|slots|. První atribut neseøazeného faktu není ve vráceném poli obsa¾en, proto¾e se k nìmu CLIPS chovají jako ke jménu skupiny faktù. Jak ji¾ bylo zmínìno vý¹e, ve skuteènosti se jedná o jméno automaticky vygenerované ¹ablony. Pro získání prvního atributu (jména) slou¾í metoda \verb|name|.

Vytvoøení seøazeného faktu je velice jednoduché, konstruktor v tomto pøípadì oèekává dva parametry. Prvním je jméno skupiny (objekt tøídy \verb|String| nebo \verb|Symbol|) a druhý pole v¹ech attributù neseøazeného faktu.

\begin{figure}[tbh]
  \begin{verbatim}
Fact.new 'Jarcec', [20, "muz"]
Fact.new 'pohlavi', %w(muz zena)
  \end{verbatim}
  \vspace{-0.7cm}
  \caption{Ukázka vytvoøení seøazeného faktu.}
  \label{rbclips_example_template}
\end{figure}

\subsubsection{Metody pøístupné pro neseøazený fakt}
Práce s neseøazenými fakty je v prostøedí rbClips o dost pohodlnìj¹í ne¾ v pøípadì seøazených faktù. Existují dvì základní metody podobné tìm, které jsou k dispozici v pøípadì seøazeného faktu. První z nich je metoda \verb|slot(String or Symbol)| vracející hodnotu ulo¾enou v daném slotu a metoda \verb|template| vracející ¹ablonu, které daný fakt odpovídá (tedy objekt tøídy \verb|Template|).

Navíc ov¹em rbClips plnì vyu¾ívá dynamiènosti a otevøenosti Ruby a pro jednotlivé sloty vytváøí pøístupové metody shodného jména jako sloty samotné. \u{C}ím¾ velice napodobuje chovani ActiveRecords, které vytváøí pøístupové metody podle názvù sloupcù relaèních tabulek. Jednotlivé instance neseøazených faktù mají rùzné metody, vygenerované podle ¹ablony, ze které byly vytvoøeny. Z toho dùvodu je dobré dávát pozor a nevytváøet ¹ablony s jmény slotù, které jsou stejné jako ji¾ existující metody. Pøíkladem nevhodného jména slotu je napøíklad \verb|save|. Pokud bude ¹ablona obsahovat takto pojmenovaný \verb|slot|, tak pùvodní metoda save, bude pøekryta metodou pro pøístup k atributùm faktu a nebude vùbec mo¾né instanci ulo¾it do prostøedí CLIPS.

V pøípadì tvorby neseøazeného faktu oèekává konstruktor dvojici parametrù. Prvním z nich musí být ulo¾ená instance ¹ablony (tøída \verb|Template|), druhým je asociativní pole, kde klíèe jsou jména slotù ¹ablony a jejich hodnoty jsou ulo¾eny do tìchto slotù pøi vytváøení faktu.

\begin{figure}[tbh]
  \begin{verbatim}
# Pro neserazeny fakt potrebuji sablonu
animal = Template.new :name => 'animal', 
  :slots => %w(name age race)
animal.save

Fact.new animal, :name => "Azor"
Fact.new animal, :name => "Zorka", :age => 2
  \end{verbatim}
  \vspace{-0.7cm}
  \caption{Ukázka vytvoøení neseøazeného faktu.}
  \label{rbclips_example_template}
\end{figure}

\subsection{Tøída Rule}
Poslední z hlavních tøíd knihovny rbClips zapouzdøuje práci s pravidly. Ty v CLIPS mají nezastupitelnou roli, proto¾e je v nich ulo¾ena informace co se má a za jakých podmínek provést. Rozhodovací jádro CLIPS jen vybírá podle rùzných mnohdy u¾ivatelsky nastavitelných kriterií které pravidla se mají a v jakém poøadí provést. V rámci CLIPS jednou vytvoøená pravidla ji¾ nelze dále upravovat, proto i rbClips vytváøí tyto objekty needitovatelné. Vyjímkou z needitovatelnosti je samozdøejmì tvorba pravidla v rámci konstruktoru tøídy.

Tvorba nového pravidla je mírnì slo¾itìj¹í a proto se jí budu detailnì v následujících odstavcích vìnovat. Nové pravidlo se vytváøí tvorbou nového objektu tøídy \verb|Ruly|, tak jak je v Ruby svìte zvykem voláním metody \verb|new|. Tato metoda vy¾aduje pøedání bloku pøijímací právì jeden argument, pøes který bude následnì celé pravidlo sestaveno. Pøedaný argument je instance tøídy \verb|RuleCreator| umo¾nující pøes své metody nadefinovat jak levou tak i pravou stranu pravidla. Levá strana pravidla slou¾í ke specifikaci v¹ech pøedpokladù, ktéré ke spu¹tìní pravidla mùsí být splnìný. Zatímco pravá strana specifikuje co se má stát po jeho aktivaci.

Velice dùle¾ité je vysvìtlit funkci symbolù v rámci vyhledávaných vzorù na levé stranì pravidla. Pomocí metod zmínìných ní¾e, lze vyhledávát urèité vzory atributù na mno¾inì existujících faktù. Mimo pøesnì specifikovaného vyhledávaného vzoru lze pou¾ít i Ruby symbol, který bude zastupovat libovolnou jednu hodnotu. Dùle¾itost této zástupnosti se projeví a¾ pøi pou¾ití stejnì pojmenovaného symbolu ve více metodách najednou v rámci jednoho pravidla. V¹echny výskyty symbolu se stejným jménem budou v¾dy nahrazeny právì jednou hodnotou. Lze takto vyhledávát podmno¾inu faktù se stejnými i kdy¾ pøedem neznámými atributy. Existují dva speciální symboly, které jsou vyjímkou z uvedeného pravidla a které se pou¾ívají v podstatì pouze u seøazených faktù. Prvním je symbol :one, slou¾ící pro nahrazení libovolné hodnoty atributu, ov¹em více výskytù mù¾e být nahrazeno více mo¾nými hodnotami. Slou¾í k pøeskakování nezajímavých hodnot neseøazených faktù, které programátora v rámci vytváøeného pravidla nezajimají. Druhým speciálním symbolem je :any.Chová se velice podobnì jako symbol :one, akorát za nìj mù¾e být v seøazeném faktu substituována více ne¾ jedna hodnota.

Nejdùle¾itìj¹í metodou pro editaci levé strany pravidla je metoda \verb|pattern|. Slou¾í pro vyhledávání urèitých vzorù (takzvaný pattern matching). Má velice bohaté mo¾nosti argumentù, se kterýmí mù¾e být volána a vrací v¾dy objekt tøídy \verb|FactAddress|. Vrácený objekt mù¾e být následnì pou¾it v metodách upravující pravou stranu pravidla. První mo¾nost volání je urèena pro vyhledávání seøazených faktù a spoèívá v pøedaní jednoho objektu tøídy String nebo Symbol a následnì jednoho pole. První argument je pou¾it jako jméno skupiny pøíbuzných faktù a pole je interpretováno jako vyhledávací vzor na této mno¾inì. Symboly v tomto poli jsou pou¾ity jako zástupné promìné, které mají v rámci aplikování pravidla v¾dy stejnou hodnotu, tak jak bylo popsáno v pøedchozích odstavcích. Druhým mo¾ným voláním je pøedat jako první argument objekt tøídy \verb|Template| a následnì jednoho asociativního pole. Velice podobnì jako v pøedchozím pøípadì potom první argument slou¾í pro urèení na jaké podmno¾inì faktù se bude vyhledávat (ve v¹ech faktech, vytvoøených podle pøedané ¹ablony). Asociativní pole obsahuje jako klíèe sloty ¹ablony a jako hodnoty vyhledávané vzory. Opìt lze pou¾ít symboly jako zástupné hodnoty stejné pøes volání v¹ech metod vytváøeného pravidla. Poslední mo¾ností je pøedat metodì \verb|pattern| jeden objekt tøídy \verb|String|, který bude beze zmìny ulo¾en do CLIPS. Slou¾í pro vlastní specifikování vyhledávaného vzoru pro pøípady, kdy rbClips nedostateènì zapouzdøuje mo¾nosti CLIPS.

Velice podobnou metodou je metoda \verb|retract|. Jako jedna z mála upravuje jak levou, tak zárovì\v{n} i pravou stranu pravidla. Na levé stranì pravidla urèuje vyhledávací vzor a proto akceptuje stejné mo¾nosti parametrù jako metoda \verb|pattern|. Navíc s ní sdíli i stejnou návratovou hodnotu, objekt tøídy \verb|FactAddress|. Na rozdíl od ní ov¹em po aktivaci pravidla nalezený fakt sma¾e.

Metody \verb|pattern| a \verb|retract| afektují levou stranu pravidla, tedy urèují za jakých podmínek se pravidlo aplikuje. Pokud je jich v definici pravidla uvedeno více, tak je mezi nì dána logická spojka a (and). Tedy v¹echny vyhledávané vzory musí být nalezeny, aby dané pravidlo mohlo být aplikováno. Pro mo¾nost jemnej¹ího definování levé strany existují tøí metody s obdobným pou¾itím - \verb|and|, \verb|or|, a \verb|not|. Tyto metody vy¾adují pøedání bloku s jedním parametrem, do kterého bude pøedán opìt objekt tøídy \verb|RuleCreator|. Vyhledávané vzory definové uvnitø pøedaného bloku budou hledáný s logickou spojkou podle pøíslu¹ného názvu metody. Pro je¹tì jemnej¹í nastavovaných podmínek rbClips umo¾\v{n}uje vzájemné zanoøovaní tìchto blokù do sebe. Dùle¾iou vyjímkou z prezentovaného chování je absence metody \verb|retract|, která v bloku \verb|not| a ve v¹ech jemu vnoøených ji¾ není k dispozici. Chybí zde z logického dùvodu, metoda \verb|retract| slou¾í po aktivaci pravidla ke smazání faktu z pamìti. Ov¹em blok \verb|not| zaruèuje, ¾e daný fakt neexistuje a logicky tedy není ani co vymazat. Velice obdobnì je uvnitø \verb|not| bloku zmìnìno chování metody \verb|pattern|, která místo objektu \verb|FactAddress| vrací \verb|nil|.

Velice u¾iteèným roz¹íøením mo¾ností CLIPS v knihovnì rbClips je mo¾nost v rámci pravé strany volat metodu libovolného objektu Ruby. Registrovaní objektu a jeho metody se provádí metodou \verb|rcall|, která má minimálnì dva povinné argumenty. Prvním je objekt, na kterém má byt zavolána metoda specifikovaná v druhém parametru. Dal¹í parametry jsou nepovinné a slou¾í k pøedání parametrù volané metody. Samozdøejmostí je mo¾nost zadat na tomto místì symbol, který v koneèném voláním metody bude nahrazenou pøíslu¹nou aktivaèní hodnotou, za kterou byl symbol nahrazen.

Poslední zatím nezmínìnou metodou objektu \verb|RuleCreator| je metoda \verb|rhs|. Akceptuje právì jeden argument tøídy \verb|String|, který bez jakýhkoliv kontrol vlo¾í do pravé strany vytváøeného pravidla. Slou¾í jako záchrana v pøípadì, ¾e po¾adovaná funkcionalita není mou knihovnou zapouzdøena.

Po vytvoøení pravidla je potøeba je ho je¹tì ulo¾it do CLIPS pomocí metody \verb|save|. Pravidla se zaènou aktivovat a¾ po spu¹tìní rozhodovacího algoritmu, který se v rbClips spou¹tí pomocí metody \verb|run| modulu \verb|Base|.

\begin{figure}[tbh]
  \begin{verbatim}
savci = Rule.new "savci" do |r|
  r.pattern 'animal', :name
  r.pattern 'warm-blooded', :name
  r.not do |n|
    n.pattern 'lays-eggs', :name
  end
  r.assert 'mammal', :name
end
  \end{verbatim}
  \vspace{-0.7cm}
  \caption{Ukázka vytvoøení pravidla.}
  \label{rbclips_example_template}
\end{figure}

\section{Praktický pøíklad}
Jako poslední kapitolu o knihovnì rbClips bych rád uvedl tro¹ku slo¾itìj¹í pøíklad spolu s jeho slovním popisem. Ukázka je zobrazena na Obrázku \ref{rbclips_complex_example1} a ukazuje vyhledávaní savcù na mno¾ine rùzných zvíøat a jejich vlastností.

Nejprve vytvoøím v¹echny fakta o zvíøatech a jejich vlastnostech za pou¾ití seøazeného faktu (poznámka \verb|#1|). Za pov¹imnutí stojí forma zápisu, kdy nepou¾ívám jeden dlouhý fakt se seznamem v¹ech vlastní daného zvíøete. Místo toho mám v¾dy vlastnost a jako jeho atribut jmého zvíøete ke kterému nále¾í. Tento zpùsob mi zjednodu¹¹í následný zápis pravidel.

První pravidlo (poznámka \verb|#2|) vyhledává savce podle dvou vlastností, za prvé musí byt teplokrevní a za druhé nesmìjí klást vajíèka. Pravidlo krásnì prezentuje pou¾ití symbolu jako zástupné promìné pro jméno zvíøete a pou¾ití bloku \verb|not|. Druhé pravidlo (poznámka \verb|#3|) vyjadøuje lidsky zapsanou vìtu ''Je-li rodiè savcem, poté i jeho potomek je savcem``. Opìt lze krásnì vidìt funkcí symbolù jako¾to zástupných znakù a to jak pro jméno rodièe, tak i pro jméno jeho potomka. Ka¾dé pravidlo bude spu¹tìno pro v¹echny platné kombinace, které budou v mno¾ine vstupních faktù nalezeny. Navíc spu¹tìní rozhodovacího algoritmu (poznámka \verb|#4|) není omezeno ¾ádným maximálním poètem aplikovaných pravidel, tak¾e rozhodovací algoritmus svou èinnost ukonèí a¾ ji¾ nebude mít ¾ádná pravidla ke spu¹tìní. 

Po dokonèení ukázkového programu pøibudou do na zaèátku vytvoøené mno¾iny faktù celkem 4 nová fakta pro savce. Na základì prvního pravidla se bude jednat o identifikování savce koèky a psa a na základì druhého pravidla je¹tì fakta pro jejich potomky, tedy kotì a ¹tìnì.

\begin{figure}[tbh]
	\begin{verbatim}
	#1
	Fact.new('animal', %w(dog)).save
	Fact.new('animal', %w(cat)).save
	Fact.new('animal', %w(duck)).save
	Fact.new('animal', %w(turtle)).save
	Fact.new('warm-blooded', %w(dog)).save
	Fact.new('warm-blooded', %w(cat)).save
	Fact.new('warm-blooded', %w(duck)).save
	Fact.new('lays-eggs', %w(duck)).save
	Fact.new('lays-eggs', %w(turtle)).save
	Fact.new('child-of', %w(dog puppy)).save
	Fact.new('child-of', %w(cat kitten)).save
	Fact.new('child-of', %w(tutrle hatchling)).save

	#2
	mammal1 = Rule.new "mammal" do |r|
		r.pattern 'animal', :name
		r.pattern 'warm-blooded', :name
		r.not do |n|
			n.pattern 'lays-eggs', :name
		end
		r.assert 'mammal', :name
	end
	mammal1.save

	#3
	mammal2 = Rule.new "childs" do |r|
		r.pattern 'mammal', :name
		r.pattern 'child-of', :name, :young
		r.assert 'mammal', :young
	end
	mammal2.save
	
	#4
	Base.run
	\end{verbatim}
 	\vspace{-0.7cm}
  \caption{Pøíklad pou¾ítí knihovny rbClips}
  \label{rbclips_complex_example1}
\end{figure}

%=========================================================================
\chapter{Závìr}
%=========================================================================
Knihovnu rbClips jsem úspì¹nì naprogramoval a odzkou¹el na základì testù, které jsem vytvoøil ve fázi navrhu rozhraní knihovny. V souèasné dobì probíha jeji dal¹í testovaní pro odhalení rùzných zavleèených chyb, kterých jsem si pøi vlastním testování nev¹iml. Dal¹ím krokem bude pou¾ít knihovnu k tvorbì expertního systému v Ruby pro automatickou klasifikaci vzorkù, tak jak jsem zmínil v úvodu. 

Výhod pou¾ítí rbClips a Ruby místo pøímého pou¾ítí CLIPS je nìkolik. Za prvé lze vyu¾ít v¹ech ji¾ napsaných knihoven Ruby. V praxi hlavnì vyu¾ijeme mo¾nosti napojení na relaèní databáze, ve kterých jsou ulo¾eny informace o malware (napøíklad kontrolní souèty). Dále nám Ruby umo¾nuje snadné volání externích utilit (napøíklad skenovací engine) a rozhodování na základì jejich výsledkù pøesnì po vzoru lidského pracovníka. Poslední výhoda se ji¾ nevztahuje k rbClips, ale ke CLIPS obecnì. Existuje mo¾nost automaticky vytváøet nová pravidla na základì zji¹tìných zkuteènosti (tedy strojové uèení).

Knihovna rbClips by se mohla vyvíjet i nadále. Souèasný stav pokrýva fakta a pravidla, ale CLIPS nabízí napøíklad i vlastní objektový jazyk COOL. Bylo by velice pìkné v budoucích verzích rbClips pøínest mo¾nost pøímeho vyu¾ítí i tìchto zatím nepokrytých èástí CLIPS.

Navíc by knihovna mohla slou¾it jako základ dopl\v{n}ku ke stávajícímu antivirovému jádru. To klasifikuje viry na základì vyhledávání rùzných vzorù v prohledávaných souborech. K tomu by ¹lo vytvoøit druhé jádro klasifikující malware na základì jeho chování (tedy behaviour detekce), jejím¾ základem by byla právì knihovna rbClips. Operaèní systém by hlásil akce jednotlivých programù. Napøíklad alokace velkého bloku souvislé pamìti, roz¹ifrování dat do této pamìti a její následné spustìní. rbClips knihovna by poté rozhodovala zda-li je chovaní programù správné a pøípustné. Pøípadnì by oznaèila daný program za malware a oznámila v¹e u¾ivateli. Samozdøejmì by výsledné nové jádro antiviru mohlo vyu¾ívat ve¹keré mo¾nosti, které nabízí jak CLIPS, tak i Ruby nabízí. Napøíklad nechat zkontrolovat stávajícím jádrem u¾ roz¹ifrovaný k\'{o}du malwaru, který pøedtím nemusel být detekován.
