%=========================================================================
\chapter{Úvod}
%=========================================================================
Poèet novì se objevujících virù a jinıch ¹kodlivıch poèítaèovıch k\'{o}dù (malwaru) rok od roku stoupá. Velice tomu pomáhá postupné roz¹iøování internetu i mezi laickou veøejnost, která se pøíli¹ netrápí dostateènım zabezpeèením svıch poèítaèù. Tento nepøíli¹ optimistickı trend zpùsobuje problémy snad ve v¹ech odvìtvích lidské èinnosti, proto¾e dnes u¾ bez oddìlení starajícího se o poèítaèovou infrastrukturu nemù¾e existovat ¾ádná vet¹í firma. Zpùsobené problémy jsou hlavnì finanèní\,--\,rostou náklady jak na zabezpeèení jednotlivıch poèítaèovıch stanic, tak i celıch poèítaèovıch sítí.

Logickou úvahou by mohl ètenáø dojít k názoru, ¾e na tomto trendu mimo producentù nevy¾ádané po¹ty profitují hlavnì rùzné bezpeèností firmy. Nejvíce pak antivirové spoleènosti, dodávající ochranná øe¹ení proti malwaru. Bohu¾el opak je pravdou. \v{S}kodlivého k\'{o}du je ov¹em nejenom více, ale bohu¾el se takté¾ dost rychle mìní. Jeho autoøi, kterıch stále pøibıvá, vynalézají nové a dùmyslnìj¹í techniky jak pøedejít odhalení antivirovım programem. Co¾ na stranì antivirovıch firem znamená poptávku po stále vìt¹ím poètu velice dobøe kvalifikovanıch lidí, kteøí jsou schopní prozkoumat podezøelé vzorky a pro ka¾dı malware vytvoøit nové virové definice.

Dostateènı poèet dobøe kvalifikovanıch lidí bohu¾el na trhu práce není k dispozici, a proto se hledají jiné, automatizovanìj¹í postupy, pro zpracování podezøelıch vzorkù. Automatizované postupy mají navíc i jiné vıhody. Poèítaè pracuje rychleji, mnohdy spolehlivìji a hlavnì vıraznì levnìji ne¾ jeho lidskı ekvivalent. Na druhou stranu mu chybí takzvanı ``zdravı selskı rozum''. Jako jeden ze zpùsobù adresace problému lidského uva¾ovaní vznikly tzv. expertní systémy. Expertní systém je program, kterı napodobuje rozhodovací proces lidského experta podle pøedem nadefinovanıch pravidel. 

V rámci spoleènosti AVG Technologies s.r.o jsme se rozhodli vytvoøit program s jádrem v expertním systému pro automatickou klasifikaci vzorkù. Vìt¹ina expertních systému je komerèních a vzhledem k tomu, ¾e se nejedná o levné programy, zvolili jsme volnì ¹iøitelnı pøíklad takového systému jménem CLIPS. Nabízí plnohodnotné prostøedí pro tvorbu expertního systému, které je napsáno v jazyce C. U¾ivatelské rozhraní, které je velice podobné jazyku LISP, je ov¹em u¾ivatelsky velice nepøívìtivé. Proto jsme se rozhodli celé CLIPS vzít a zapouzdøit do nìjakého vy¹¹ího programovacího jazyka. Jako cílovı jazyk pro zapouzdøení jsme se rozhodli vyu¾ít moderní skriptovací jazyk Ruby, kvùli jeho zajímavım a neobvyklım mo¾nostem.

Má bakaláøská práce pojednává o novì vytvoøené knihovnì rbClips, která umo¾\v{n}uje pou¾ívat nástroj pro tvorbu expertních systémù CLIPS v jazyce Ruby. Knihovna bude následnì pou¾ita k tvorbì systému pro automatické rozpoznávání vzorkù tak, jak bylo nastínìno v úvodních odstavcích. Samotnı systém pro klasifikaci vzorkù u¾ ov¹em není obsahem této práce.

Zbytek této práce je rozdìlen do dvou kapitol. Po této první úvodní kapitole následuje popis pou¾itıch technologií. Tedy úvod do programovacího jazyka Ruby s dùvody proè jsme se rozhodli pou¾ít pravì jej. A následnì také úvod do problematiky expertních systémù a nástroje CLIPS. Následující kapitola se ji¾ vìnuje èistì knihovnì rbClips, vısledku mé práce. Budu se zde zabıvat jak návrhem a popisem rozhraní tak i rùznımi zajímavımi implementaèními detaily.

%=========================================================================
\chapter{Pou¾ité technologie}
%=========================================================================
Jak jsem popsal v úvodu, cílem mé bakaláøské práce je vytvoøit knihovnu rbClips umo¾nující propojit CLIPS a Ruby. V následujících dvou kapitolách se obìma technologiemi budu zabıvat více do hloubky a vysvìtlím proè jsme se rozhodli pou¾ít právì je. Obì technologie jsou napsány v programovacím jazyce C, proto i moje knihovna bude napsána v tém¾e jazyce. Samotnı popis jazyka C jsem ji¾ ov¹em do své práce nezahrnul a lze jej najít napøíklad v knize~\cite{programovaciJazykC}.

\section{Ruby}
Ruby~\cite{webRuby} je relativnì mladı dynamickı skriptovací jazyk vytvoøenı japonskım in¾enırem Yukihiro Matsumoto, známım pod pøezdívkou Matz. V souèasné dobì neexistuje ¾ádná specifikace èi norma popisující tento jazyk jako je tomu napøíklad u jazykù C, C++ a dal¹ích. Z tohoto dùvodu se jako reference jazyka bere samotnı interpret napsanı Matzem\,--\,Matz' Ruby Interpret (MRI). Interpretù existuje více a jejich zkrácenı seznam je uveden dále v textu. Absence existujícího standartu vedla v roce 2008 k vytvoøení skupiny pro standardizaci jazyka v rámci japonské organizace Information-technology Promotion Agency (IPA), která vychází z MRI verze 1.8.7. V souèasné dobì je k dispozici ji¾ návrh standardu\footnote{http://ruby-std.netlab.jp/draft\_spec/agreement.html}, kterı má bıt navr¾en ke schválení prvnì v Japonsku u standardizaèní komise Japanese Industrial Standards Committee (JISC) a následnì i u International Standard Organization (ISO).

\subsection{Historie}
První verze interpretu Ruby vytvoøená Matzem byla zveøejnìna u¾ v roce 1995 (velice zajímavı je fakt, ¾e jméno nového jazyka u¾ bylo vybráno v roce 1993, tedy o cele dva roky døíve), ov¹em oficiální webové stránky jazyka v angliètinì byly k dispozici a¾ o tøi roky pozdìji, tedy v roce 1998. Absence kvalitních materiálù v angliètinì je jedním z hlavních dùvodù, proè se Ruby stal populárním prvnì pouze v Japonsku a velice pomalu se dostával i do ostatních státù svìta. V dne¹ní dobì u¾ na¹tìstí není problém najít kvalitní zdroje informací ani v angliètinì ani v èe¹tinì, èi dal¹ích jazycích, a to jak ve webové, tak i v kni¾ní podobì. Tato i dal¹í zajímavá data jsou shrnuta na Obrázku~\ref{ruby_history}, která jsem èerpal z prezentace vytvoøené k pøíle¾itosti konference RubyConf 2006~\cite{webRubyHistory}.

Matz vytvoøil novı jazyk, proto¾e ho nadchly mo¾nosti skriptovacích jazyku a ¾ádnı z tehdy dostupnıch jazykù ho nezaujal\footnote{http://linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html}. Chtìl jazyk mocnìj¹í ne¾ Perl~\cite{programmingPerl} a více objektovì orientovanı ne¾ Python~\cite{programmingPython}.  Na otázku, proè vytvoøil dal¹í skriptovací jazyk, Matz je¹tì èasto dodává dùvody syntaxe. Programovacích jazykù je mnoho a jsou svım zpùsobem velice podobné (vlastnostmi i schopnostmi). Matz ov¹em chtìl jazyk, ve kterém ho bude bavit psát a nebude se muset pøíli¹ trápit se zápisem jednotlivıch konstrukcí. Syntaxe by mìla bıt podøízena èlovìku jako¾to pisateli jazyka, nikoliv poèítaèi jako¾to interpretu jazyka.

V souèasnosti se udr¾ují dvì hlavní vìtve MRI\,--\,verze 1.8 a 1.9. Vìtev~1.8 je pova¾ována za stabilní a ji¾ se v ní pouze opravují chyby, hlavní vıvoj probíhá ve vìtvi~1.9.

\begin{figure}[t]
  \begin{center}
  \begin{tabular}{|c|l|}
    \hline
    1993 & Vybráno jméno. \\
    1995 & První zveøejnìná verze interpretu (verze 0.95). \\
    1996 & Verze 1.0. \\
    1997 & Matz zamìstnán jako Ruby programátor na plnı úvazek. \\
    1998 & Webové stránky v angliètinì a vznik anglicky psaného mailing listu. \\
    1999 & První kniha o Ruby (psána japonsky). \\
    2000 & Zaèátek roz¹iøování povìdomí o Ruby mimo hranice Japonska. \\
    2001 & YARPC - Yet Another Ruby and Perl Conference. \\
    \hline
  \end{tabular} 
  \end{center}
  \caption{Shrnutá historie v datech.}
  \label{ruby_history}
\end{figure}

\subsection{Vlastnosti ruby}
Ruby je dynamickı skriptovací jazyk mnoha rùznıch paradigmat\,--\,je plnì objektovì orientovanı, ale lze v nìm bez problémù psát i imperativnì èi funkcionálnì. Následuje popis vybranıch vlastností, které bych rád vyzdvihl, èi na nì upozornil. Podle potøeby budu dále v textu srovnávat Ruby s dal¹ími jazyky které znám\,--\, Java~\cite{javaInANutschell} a C++~\cite{cppInANutschell}.

Ní¾e uvedenı popis vlastností jsem èerpal ze své osobní zku¹enosti s tímto programovacím jazykem a z velice obsáhlého popisu jazyka napsaného samotnım autorem Ruby, The Ruby programming language~\cite{rubyProgrammingLanguage}, která je zrevidování a roz¹íøení døíve vydané knihy Ruby in Nutshell~\cite{rubyInNutshel}. A z knihy Metaprogramming Ruby~\cite{metaprogrammingRuby}, která se zabıvá nejen metaprogramováním v Ruby, ale také velice èitelnım zpùsobem vysvìtluje objektovı model ruby a dal¹í jeho aspekty.

V dal¹ích odstavcích pøedpokládám, ¾e je ètenáø seznámen se základními konstrukcemi jazyka Ruby, na nich¾ popí¹i jeho zajímavé a neobvyklé vlastnosti jako volnìj¹í syntaxi, dynamiènost, otevøenost objektù spolu s objektovım modelem a bli¾¹í popis práce s bloky. V pøíkladech budu mimo jiné vyu¾ívat konstrukci \verb|# =>|, která se v Ruby svìtì bì¾nì pou¾ívá pro uvedení návratové hodnoty pøíkazu. Znak \verb|#| slou¾í jako úvodní znak komentáøe, proto konstrukce nijak neovlivòuje vykonávání napsaného kód.

\subsubsection{Objektovost}
Ruby je plnì objektovì orientovanı jazyk (byl mimo jiné inspirován i Smalltalkem~\cite{smalltalk}), co¾ znamená, ¾e v¹e v Ruby je objekt. Nejsou zde ¾ádná datová primitiva jako \verb|int| èi \verb|double| podobnì jak tomu je v Javì a C++. \v{C}íselné a jiné konstanty jsou interpretem okam¾itì pøevádìny na instance pøíslu¹nıch tøíd. Pøíklad na Obrázku~\ref{ruby_objektovost_fig1} ukazuje mo¾nost volání metody na èíselné konstantì bez nutnosti explicitní konverze na objekt.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
123.class         # => Fixnum
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Automatická konverze konstanty na odpovídající objekt.}
  \label{ruby_objektovost_fig1}
\end{figure}

Interpret po svém startu vytvoøí bezejmennou instanci tøídy \verb|Object| a v jejím kontextu následnì vykoná pøedanı skript. Odpadá tedy nutnost explicitnì vytváøet tøídu s minimálnì jednou veøejnou metodou \verb|main()|, která se spustí po startu aplikace, jako je tomu v Javì nebo funkci \verb|main()| v pøípadì C++. Ukázkovı ``Hello world!'' program, kterı v Ruby vypadá takto: \verb|puts "Hello world!"|, je tedy objektovı k\'{o}d, i kdy¾ se tak na první pohled nezdá. Tvrzení lze dokázat vypsáním tøídy aktuálního objektu \verb|puts self.class|, která vrátí \verb|Object|, i kdy¾ pro pisatele v ¾ádném objektu není (\verb|self| je obdoba ukazatele \verb|this| z jazyka C++, tedy reference na aktuální objekt),

Dal¹í a pro mì v dobì, kdy jsem se s Ruby poprvé seznamoval, velice pøekvapivı dùsledek plné objektovosti je fakt, ¾e tøídy samy jsou objekty podobnì jako v jazyce Smalltalk. Napøíklad objekt ``abcd'' je tøídy \verb|String|,  samotná tøída a objekt zárovì\v{n} \verb|String| je tøídy \verb|Class|, co¾ jde vidìt na Obrázku~\ref{ruby_objektovost_fig2}. Z tohoto pøístupu plyne nìkolik dùsledkù: (1) je potøeba rozli¹ovat mezi tøídní metodou a instanèní metodou, (2) tøídy mohou mít své instanèní promìnné a (3) existuje mo¾nost dìdit i na mno¾inì objektù, ze kterıch se vytváøejí tøídy. Z praktického pohledu se na tuto vlastnost lze koukat jako na statické promìnné a metody u jazyka C++. Pro lep¹í pochopení je na Obrázku~\ref{fig_ruby_inst_obj_2} naznaèeno umístìní metod a promìnnıch jak ve tøídì, tak i ve tøídì tøídy.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
"abc".class       # => String
String.class      # => Class
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ruby tøída je plnohodnotnı objekt.}
  \label{ruby_objektovost_fig2}
\end{figure}

Schopnosti dìdit na mno¾inì objektù, ze kterıch se vytváøejí tøídy vyu¾ívá i objektovı model Ruby. Tøída \verb|Class| pou¾ívaná pro tvorbu tøíd dìdí od velmi specifické tøídy \verb|Modul|, kterou roz¹iøuje hlavnì o metodu \verb|new| slou¾ící pro tvorbu novıch instancí. Modul je zjednodu¹ená tøída, kolekce metod, od které nelze vytváøet instance ov¹em lze je vkládat dovnitø jinıch tøíd a tím nahrazovat absenci vícenásobné dìdiènosti v Ruby.

\begin{figure}[t]
  \centering
  \includegraphics[width=11cm,keepaspectratio]{fig/fig-ruby-inst_obj_2.png}
  \caption{Tøída je také objekt.}
  \label{fig_ruby_inst_obj_2}
\end{figure}

\subsubsection{Volná syntaxe}
Jak u¾ bylo zmínìno vı¹e, Matz chtìl vytvoøit jazyk, ve kterém by ho bavilo programovat. Jazyk, ve kterém by nemusel poøád pøemı¹let nad syntaxí, kterı by byl krásnì èitelnı a hlavnì, pokud mo¾no, co nejbli¾¹í bì¾nému lidskému jazyku. Cíl se mu povedl, proto¾e ukázky k\'{o}du na Obrázku~\ref{ruby_syntaxe_fig1} opravdu pøi ètení pøipomínají anglické vìty, popisující co, se má udìlat. Tato vlastnost má vliv na syntaktickou analızu kódu, která je mnohem slo¾itìj¹í.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
3.times do puts 'Ahoj' end      # 3x vypis "ahoj"
puts "Ahoj" if name == "jarcec" # vypis Ahoj pokud je jmeno "jarcec"
  \end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ukázky èitelnosti k\'{o}du.}
  \label{ruby_syntaxe_fig1}
\end{figure}

Jedním ze zpùsobù pøizpùsobení gramatiky jazyka programátorovi je mo¾nost vynechat závorky oddìlující název metody od jejich parametrù v místech, kde to není syntakticky nejednoznaèné. Lze tedy zavolat metodu \verb|naDruhou| s parametrem 5 tak, jak je zvykem v Javì a C++ \verb|naDruhou(5)|, nebo na mnoha místech více èitelnìji \verb|naDruhou 5|. Volání metody bez závorek vypadá na mnoha místech spí¹e jako klíèové slovo ne¾ obyèejné volání metody.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
class Human < ActiveRecord::Base
  has_many     :articles
  belongs_to   :department
end
\end{verbatim} 
\end{minipage}
  \vspace{-0.2cm}
  \caption{ActiveRecord ukázka prezentující volitelné vynechání závorek.}
  \label{ruby_syntaxe_fig2}
\end{figure}

Na první pohled se to mù¾e jevit spí¹e jako matoucí, ale uvedenı  pøíklad z Obrázku~\ref{ruby_syntaxe_fig2}) z webového frameworku Ruby on Rails~\cite{rubyOnRails} (RoR) ukazuje opak. I èlovìk bez znalosti Ruby nebo RoR, ov¹em se znalostí jiného programovacího jazyka, je schopen s velkou úspì¹ností odhadnout, ¾e prezentovanı pøíklad vytváøí tøídu \verb|Human|, s urèitou závislostí na oddìlení (department), a kterı napsal mnoho rùznıch èlánkù (articles).

Tento spí¹e sociální efekt (``Jedná se o metodu nebo klíèové slovo?'') jde v Ruby velice hluboko. Mnohdy lze u¾ v úvodních tutoriálech najít zmínku o klíèovém slovì \verb|puts| slou¾ícímu pro vıpis na standardní vıstup (obdoba \verb|printf()| z jazyka C). Ve skuteènosti se ov¹em nejedná o klíèové slovo, ale o metodu modulu \verb|Kernel|, kterı ka¾dı objekt zdìdí, a proto je na ka¾dém místì programu dostupná. Jedná se tedy o zcela normální metodu a lze ji stejnì jako jakoukoliv jinou v pøípadì potøeby pøetí¾it, popøípadì z objektu odstranit...

Mo¾nost vynechat psaní závorek na ka¾dém místì pova¾uji za kladnou vlastnost, kterou velice èasto a rád vyu¾ívám. Na druhou stranu, ov¹em, musím upozornit na její dopady\,--\,i pouhá mezera mù¾e zmìnit logiku kódu. Na Obrázku~\ref{ruby_syntaxe_fig3} uvádím dva pøíklady li¹ící se pouhou jednou mezerou oznaèenou symbolem \verb*| | mezi koncem názvu metody a otevírající závorkou. V prvním pøípadì syntaktickı analyzátor najde ihned za názvem metody závorku. Ví tedy, ¾e uvnitø se nacházejí parametry, se kterımi se metoda má volat a a¾ následná vrácená hodnota se vynásobí dvìma. Vısledek bude $18$ (=$3^2  * 2$). V druhém pøíkladì syntaktickı analyzátor najde za názvem metody mezeru a pøistupuje k volání jinak. Ví, ¾e následuje seznam argumentù oddìlenı èárkami, proto¾e závorky okolo argumentù jsou vynechány. Na øádce se ov¹em ¾ádná èárka nenachází, a tedy celı vıraz $(1+2)*2$ je metodì pøedán jako jeden argument s vısledkem $36$ (=$((1+2) * 2)^2$).

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim*}
puts naDruhou(1+2)*2
puts naDruhou (1+2)*2
\end{verbatim*}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Dùle¾itı vıznam mezer.}
  \label{ruby_syntaxe_fig3}
\end{figure}

Ruby neumo¾òuje pojmenovat argumenty metod podobnì jako Python, ov¹em díky volné syntaxi pro vytvoøení asociativního pole (hashe) lze toto chování napodobit. Pøíkladem mù¾e bıt volání fiktivní metody pro hledání na Obrázku~\ref{ruby_syntaxe_fig_X_1}, kde opticky pøedávám dva pojmenované parametry\,--\,name a surname. Ve skuteènosti je tento zápis reprezentován jako tvorba asociativního pole o dvou polo¾kách, s klíèi name a surname, a a¾ následnì je toto pole pøedáno metodì \verb|find| jako jeden argument. Webovı framework RoR tento pøístup pou¾ívá velmi èasto.

Poslední poznámka k volné syntaxi: Ruby umo¾òuje stejnì jako Perl otoèení poøadí zápisu neúplné podmínky a jejího tìla (viz. Obrázek~\ref{ruby_syntaxe_fig4}).

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
find :name => 'Jarek', :surname => 'Cecho'
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Pøedávání asociativního pole jako jednoho argumentu.}
  \label{ruby_syntaxe_fig_X_1}
\end{figure}

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
if osoba == 'jarcec' then print "Ahoj Jarcec"; end
print "Ahoj Jarcec" if osoba == 'jarcec'
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Pøehození poøadí zápisu neúplné podmínky a jejího tìla.}
  \label{ruby_syntaxe_fig4}
\end{figure}


\subsubsection{Dynamiènost a otevøenost}
Dynamièností Ruby rozumím provádìní mnoha èinností, které jsou v pøípadì C++ a Javy provádìny u¾ v dobì kompilace, a¾ za bìhu programu. Vzhledem k plné objektovosti (v¹e je objekt) nemá moc smysl mluvit o typovosti jazyka, proto¾e existuje pouze jedinı datovı typ, kterım je objekt.

Z dynamiènosti vyplıvá mnohem zajímavìj¹í a ne a¾ tak bì¾ná vlastnost Ruby, kterou je otevøenost. Ka¾dı objekt mù¾e bıt za bìhu otevøen a roz¹íøen o nové metody, podobnì jako je tomu u JavaScriptu~\cite{learningJavascript}. Velice èasto se toho vyu¾ívá u tøíd (napøíklad roz¹íøením vestavìné tøídy o nové metody). Tuto vlastnost by do urèité míry ¹lo nahradit dìdièností (nové metody ulo¾it do potomka), ale jen pokud se roz¹iøují tøídy. V Ruby je v¹e objekt, tak¾e roz¹íøit lze nejen tøídy, ale dokonce i instance jednotlivıch tøíd (viz. Obrázek~\ref{ruby_dynamicnost_fig1}), co¾ byl pro mì jako¾to programátora znalého jazyka C++ docela ¹ok pøi seznamování se s tímto jazykem. Mo¾nosti roz¹íøení instancí o nové metody pou¾ívám i ve své práci, co¾ popisuji v kapitole~\ref{rbclips_facts} v èásti o zpracování Faktù.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
class A                 # definovani tridy jmenem "A"
  def metodaA           # definovani metody jmenem "A"
    4                   # tato metoda bude vracet cislo 4
  end
end

a = A.new               # vytvoreni prvni instance tridy A
a.metodaA               # => 4
b = A.new               # vytvoreni druhe instance tridy A

def b.metodaB           # vytvoreni metody pouze v instanci b
  5                     # tato metoda bude vracet cislo 5
end

b.metodaB               # => 5
a.metodaB               # => Exception NoMethodError
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Pøidávání metod do instancí tøíd.}
  \label{ruby_dynamicnost_fig1}
\end{figure}

Díky dynamiènosti a otevøenosti se v Ruby velice pìknì metaprogramuje, co¾ znamená psaní kódu, kterı generuje dal¹í kód). Jedná se o velice èasto vyu¾ívanou schopnost jazyka a velké projekty v Ruby jsou metaprogramováním dosti ovlivnìny. Pøíkladem mù¾e bıt projekt ActiveRecords\footnote{Oficiální dokumentace k projektu ActiveRecords je dostupná na http://ar.rubyonrails.org/. Na adrese http://guides.rubyonrails.org/ je v sekci Models k dispozici laicky èitelnı úvod do tohoto projektu.}, kterı zapouzdøuje èinnost s relaèními databázemi tak, aby se u¾ivatel s SQL~\cite{sqlCookbook} vùbec nesetkal. V¹e je pro nìj zapouzdøeno do objektù.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
# trida popisujici relacni tabulku humans
class Human < ActiveRecords::Base
end

jarcec = Human.new       # vytvor novy radek v tabulce
jarcec.name = "Jarek"    # napln sloupec jmeno
jarcec.surname = "Cecho" # napln sloupec prijmeni
jarcec.save              # uloz radek do tabulky
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ukázka pou¾ití knihovny ActiveRecords.}
  \label{ruby_dynamicnost_fig2}
\end{figure}

V definici tøídy z Obrázku~\ref{ruby_dynamicnost_fig2} chybí deklarace metod \verb|name| a \verb|surname| a pøesto danı k\'{o}d bude fungovat. Konstruktor tøídy se toti¾ pøi inicializaci podívá do databáze na strukturu tabulky kterou popisuje, v tomto pøípadì tabulky \verb|humans|, a vytvoøí ke v¹em nalezenım sloupcùm pøíslu¹né metody pro ètení i zápis. Tento pøístup velice usnad\v{n}uje údr¾bu k\'{o}du. V definici tøídy není seznam sloupcù jednotlivıch tabulek, a proto pøi zmìnì databázového schématu není nutné v¹e upravovat a zvedat tak pravdìpodobnost zavleèení chyby díky inkonzistenci seznamu sloupcù v databázi a v definici tøídy.

O metaprogramování v Ruby byla napsána velice pìkná kniha jménem Metaprogramming Ruby~\cite{metaprogrammingRuby}. Psána je spí¹e laickım stylem a na praktickıch pøíkladech popisuje, co pøesnì se pod poj\-mem metapogramovaní skrıvá, a jak toho v Ruby co nejefektivnìji vyu¾ít.

\subsubsection{Bloky}
Blok je podobnì jako v C++ nebo Javì sekvence pøíkazù ohranièená slo¾enımi závorkami. V pøípadì Ruby je je¹tì mo¾né blok ohranièit klíèovımi slovy \verb|do| a \verb|end|. Na rozdíl od zmínìnıch jazykù v Ruby jde s bloky dìlat o dost vìt¹í kouzla, a proto je zmi\v{n}uji v samostatné èásti. První dùle¾itı rozdíl je mo¾nost pøedat bloku parametry (blok se pak vlastnì chová jako bezejmenná funkce). Dal¹í rozdíl je schopnost bloky v Ruby pøedávat do metod.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
   \begin{verbatim}
["AHOJ", "NAZDAR", "HI"].map{|prvek| prvek.downcase}
      # => ["ahoj", "nazdar", "hi"]
\end{verbatim}
\end{minipage}
    \vspace{-0.2cm}
  \caption{Ukázka pøedání bloku metodì.}
  \label{ruby_bloky_fig1}
\end{figure}

Pøíkladem mù¾e bıt zámìna velikosti písmen v poli øetìzcù na Obrázku~\ref{ruby_bloky_fig1}. Metoda \verb|map| tøídy \verb|Array| pøijímá blok akceptující jeden parametr a pro ka¾dı prvek v poli tento blok zavolá. Návratovou hodnotu bloku (v Ruby je v¹e vıraz, i bloky tedy vracejí hodnoty, tato vlastnost je detailnìji popsána ní¾e) ulo¾í do pole na místo volaného prvku. Ukázka tedy zmen¹í velikost písmen pro ka¾dı prvek v poli.

S bloky se pojí jeden dùle¾itı pojem\,--\,uzávìr (closure). Ka¾dı blok si s sebou nese vazby na lokální promìnné známé v dobì jeho vzniku. V pøíkladu na Obrázku~\ref{ruby_bloky_fig2} si blok zapamatuje svou lokální promìnnou \verb|a| (s hodnotou 30) a nese si ji s sebou i do metody \verb|foo|, odkud je poté zavolán (pomocí klíèového slova \verb|yield|). Ukázka vypí¹e èíslo 30, proto¾e \verb|a| je lokální promìnná z kontextu, ve kterém byl pøedanı blok vytvoøen. Pokud by chtìla metoda \verb|foo| vytisknout svou hodnotu promìnné \verb|a|, musela by ji pøedat do bloku pøes parametr.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
def foo           # definice metody foo
  a = 10          # deklarace vlastni promene a
  yield           # zavolej predany blok
end

a = 30            # druhy deklarace promene a
foo { puts a }    # zavolani funkce foo
\end{verbatim} 
\end{minipage}
  \vspace{-0.2cm}
  \caption{Vazby na lokální promìné v pøípadì pøedanıch blokù.}
  \label{ruby_bloky_fig2}
\end{figure}

\subsubsection{Tøída Symbol}
Symbol je textovı øetìzec podobnı øetìzcùm tøídy \verb|String|, kterı se pro odli¹ení pí¹e s dvojteèkou pøed vlastním øetìzcem. Pokud je symbol navíc slo¾en pouze z písmen, je mo¾né vynechat i jinak povinné uvozovky èi apostrofy (ukázky mo¾ností zápisu symbolu jsou na Obrázku~\ref{ruby_symboly_fig1}).

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
:ahoj             # symbol s hodnotou "ahoj
:'ahoj, tady jezisek' # dlouhy retezec jako symbol
:'4'              # symbol s hodnotou "4"
\end{verbatim} 
\end{minipage}
  \vspace{-0.2cm}
  \caption{Rùzné zpùsoby zadání symbolu.}
  \label{ruby_symboly_fig1}
\end{figure}

Symboly v Ruby mají nìkolik odli¹nıch vlastností od tøídy \verb|String|. Za prvé se jedná o objekty pouze pro ètení (nelze zmìnit jejich hodnotu, vlastní text symbolu). Druhı a podstatnìj¹í rozdíl je v rovnosti a identitì. V ukázce na Obrázku~\ref{ruby_symboly_fig2} se provádí dvì dvojice porovnání na objektech tøíd \verb|String| a \verb|Symbol|. V prvním testu porovnávám objekty, zda-li se rovnají (mají-li stejnı obsah). Druhı test se ptá na jednoznaènı identifikátor objektu. Testuje tedy identitu objektu. Testy na rovnost samozøejmì v¾dy uspìjí, proto¾e jak symbol, tak øetìzec obsahují stejné hodnoty. Ov¹em test na identitu v pøípadì øetìzce sel¾e, proto¾e se jedná o dva rùzné objekty (vytvoøené interpretem pøi parsování zdrojového k\'{o}du programu). Symboly jsou si ov¹em identické - jedná se o jednu instanci. Tato dùle¾itá vlastnost symboly pøedurèuje k pou¾ití na místech konstant nebo klíèù do asociativních polí. Symbol s danım textem existuje v pamìti maximálnì jednou, bez ohledu na poèet vıskytù v programu, co¾ vede k ¹etøení pamìti a zvı¹ení vıkonu aplikace.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
'ahoj' == 'ahoj'                     # => true
'ahoj'.object_id == 'ahoj'.object_id # => false

:ahoj == :ahoj                       # => true
:ahoj.object_id == :ahoj.object_id   # => true
\end{verbatim} 
\end{minipage}
  \vspace{-0.2cm}
  \caption{Porovnání a test identity symbolu a textového øetìzce.}
  \label{ruby_symboly_fig2}
\end{figure}


Na úrovní zdrojovıch k\'{o}du MRI je tato vlastnost implementována pomocí tabulky jednoznaènì pøevádìjící textovou reprezentaci symbolu na datovı typ \verb|ID| (co¾ je pøedefinovanı typ \verb|unsigned long|). Ve¹kerá porovnávání na rovnost symbolu jsou ve skuteènosti celoèíselná porovnání, která jsou rychlej¹í ne¾ øetìzcová, èím¾ se dosahuje optimalizace. Java obsahuje velice obdobnı mechanismus pomocí volání \verb|String.intern()|, C++ nic jako symbol bohu¾el nezná.

\subsubsection{Drobnosti}
Dále bych se chtìl u¾ jenom krátce zmínit o nìkolika vlastnostech Ruby, které popisem nevydají na samostatnou èást, ale pøesto si myslím, ¾e by zde mìly bıt uvedeny.

Mimo faktu, ¾e v¹e je objekt, je ka¾dá jazyková konstrukce vıraz (má svou návratovou hodnotu). Tedy i øídící konstrukce (\verb|if|, \verb|while|, ...) nìco vrací - podle funkce pøíslu¹né konstrukce je to tøeba hodnota posledního vykonaného pøíkazu nebo objekt \verb|nil|, kterı je popsán ní¾e. (Obrázek~\ref{ruby_drobnosti_fig1}).

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
if 1 == 2         # porovnej cislice 1 a 2
  puts "1 == 2"   # vypis text
end               # => nil
\end{verbatim} 
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ka¾dá jazyková konstrukce je vıraz.}
  \label{ruby_drobnosti_fig1}
\end{figure}

Ruby je plnì objektovı a v¹e je objekt, popøípadì jeho metoda. I aritmetické operátory jsou tedy ve skuteènosti metody a jejich zápis bez pøístupové teèky je jen ''syntax sugar`` (jak se doslovnì uvádí v knize~\cite{rubyProgrammingLanguage}). Lze je tedy podobnì jako v C++ pøetí¾it nebo z daného objektu úplnì odstranit (Obrázek \ref{ruby_drobnosti_fig2}).

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
class Fixnum      # otevreni tridy Fixnum
  def +(oth)      # predefinovani metody +
    self * oth    # ktera bude ted nasobit
  end
end               # => nil

4 + 2             # => 8 
\end{verbatim} 
\end{minipage}
  \vspace{-0.2cm}
  \caption{Aritmetické operátory jsou normální metody.}
  \label{ruby_drobnosti_fig2}
\end{figure}

Ruby podporuje pouze jednoduchou dìdiènost, co¾ znamená, ¾e tøída mù¾e mít maximálnì jednoho pøedka. Ov¹em absenci implementaènì slo¾ité vícenásobné dìdiènosti vynahrazuje mo¾ností vkládat do sebe moduly (Obrázek~\ref{ruby_drobnosti_fig3}).

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
module Ahoj       # deklarace modulu Ahoj
  def ahoj        # s metodou ahoj
    "Ahoj"        # vracejici text "Ahoj
  end
end

class Pozdravy   # deklarace tridy Pozdravy
  include Ahoj   # vlozeni modulu Ahoj
end

p = Pozdravy.new # tvorba instance tridy Pozdravy
p.ahoj # => "Ahoj" # zavolani metody z modulu
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Moduly lze vkládat do tøíd.}
  \label{ruby_drobnosti_fig3}
\end{figure}

Na rozdíl od C++ èi Javy jsou v Ruby povoleny na konci metod i jiné znaky ne¾ jen znaky anglické abecedy, èísla a podtr¾ítko. Co¾ má velikı dopad na zlep¹enou èitelnost k\'{o}du, jeliko¾ podle konvencí metody vracející boolovskou hodnotu jsou ukonèeny znakem otazníku (napøíklad \verb|Object#nil?|) a metody mìnící stav samotného objektu jsou pro zmìnu ukonèeny vykøièníkem (napøíklad \verb|Array#map!|).

\subsection{Implementace Ruby}
Nejznámìj¹í a asi i souèasnì nejvíce pou¾ívanou implementací Ruby je interpret MRI (Mat'z ruby interpret) od autora jazyka. Ten má ov¹em své velké nedostatky. Pøednì pou¾ívá tzv. mark and sweep garbage collector. Ten v rámci své ''mark`` fáze zmrazí provádìní programu, co¾  se neblaze odrá¾í na celkové rychlosti interpretace. Dále obsahuje takzvanı ''Global interpreter lock`` (GIL), kterı znemo¾\v{n}uje paralelní zpracování. Programy sice mohou bì¾et ve vláknech, ale kvùli jeho u¾ití mù¾e v jednu chvíli bì¾et maximálnì jedno vlákno.

Jako podklad pro následnı seznam alternativních implementací jsem pou¾il seznam interpretù a jejich srovnání na webu igvita~\cite{webIgvia}.

\subsubsection{Ruby Enterprise edition}
Jedná se o vıvojovou vìtev MRI implementace verze 1.8.7\footnote{http://www.rubyenterpriseedition.com/index.htm} s vylep¹enou správou pamìti a vymìnìnım garbage collectorem. Vznikla jako potøeba optimalizovat Ruby pro bìh na serverech pro webové aplikace postavené na Ruby on Rails a je pro nì optimalizována. Je plnì kompatibilní s Ruby verze 1.8.7 a podle oficiálních stránek v urèitıch pøípadech a¾ o 33\% rychlej¹í. Na portále RubyInside je k dispozici záznam pøedná¹ky~\cite{webMRIImprovements} obou autorù  z konference Google Tech Talk (2009, San Francisco), o dùvodech proè se do úprav pustili a také o optimalizacích, které provedli.

\subsubsection{JRuby}
JRuby\footnote{http://jruby.org} je implementace Ruby v Javì vyu¾ívající plnì mo¾ností Java Virual Machine. Napøíklad umo¾òuje plnou paralelizaci (¾ádnı GIL). V souèasnosti se pracuje na podpoøe Ruby verze 1.9. Jedná se o velmi ¾ivı projekt se 7 aktivními vıvojáøi (MRI naproti tomu je z nejvìt¹í èásti vyvíjeno pouze jedním èlovìkem).

\subsubsection{BlueRuby}
Jedná se o implementaci Ruby bì¾ícího uvnitø SAP ERP~\cite{sapR3} produktu, tedy dal¹í mo¾nost jak roz¹íøit platformu SAP mimo jazykù ABAP~\cite{abapBasics} a Java. Zatím je projekt pouze ve stádiu experimentální implementace\footnote{https://wiki.sdn.sap.com/wiki/display/Research/BlueRuby} a nehodí se pro reálné nasazení.

\subsubsection{Rubinius}
Zajímavı nápad napsat co nejvìt¹í èást Ruby v samotném Ruby\footnote{http://rubini.us} - jedná se o pøepsání nez\-bytnì nutnıch èástí interpretu do C++ a zbıvajícího k\'{o}du do Ruby (napøíklad standardní tøídy - \verb|String|, \verb|Array|, \verb|Hash|, ...). Interpret obsahuje just in time (JIT) kompilátor\,--\,parsovanı skript pøelo¾í prvnì do binárního k\'{o}du spustitelného na dané platformì a a¾ ten následnì spustí. Tímto dosahuje zrychlení oproti MRI. Díky kompilaci do nativního k\'{o}du není zatí¾en GIL a umo¾òuje tedy plnı paralelismus. V souèasné dobì je tento projekt stále ve vıvoji - nìkolik aplikací v nìm ji¾ bì¾í, ale pro reálné nasazení není pøíli¹ vhodnı.

\subsection{Binární roz¹íøení}
Binární roz¹íøení skriptovacího jazyka je dynamická knihovna napsaná vìt¹inou ve stejném jazyce jako cílovı interpret. Tyto knihovny pøi naèítání zpravidla zaregistrují v interpretu nové tøídy a jejich metody namapují na své vlastní funkce. Tímto postupem se roz¹íøí mno¾ina dostupnıch tøíd a funkcionalita dostupná programátorovi skriptovacího jazyka. V pøípadì MRI verze Ruby jsou roz¹íøení psaná v jazyce C. Lze je psát i v C++, ale kvùli odli¹nım pøekladovım a linkovacím konvencím se jedná o vıjimeèné pøípady.

Dùvodù, proè napsat binární roz¹íøení místo kódu ve skriptovacím jazyce se dá najít nìkolik. Prvním, a asi i nejpodstatnìj¹ím, je rychlost. Programy napsané v jazyce C budou provádìny rychleji ne¾ jejich skriptovací ekvivalenty, a proto zapouzdøení nejnároènìj¹ího kódu z Ruby do jazyka C pøiná¹í vıkonnostní vylep¹ení. V rámci standardních Ruby tøíd je k dispozici modul pro práci s XML jménem \verb|REXML| napsanı v èistém Ruby. Existuje k nìmu nìkolik alternativ, z nich¾ napøíklad libxml-ruby\footnote{http://libxml.rubyforge.org/}(binární roz¹íøení zapouzdøující práci s XML knihovnou libxml\footnote{http://xmlsoft.org/}) je podle webovıch stránek projektu a¾ o dva øády rychlej¹í.

Druhım dùvodem mù¾e bıt nutnost. Standardní knihovny nemusí zpøístup\v{n}ovat v¹echny po¾adované nízkoúrov\v{n}ové operace operaèního systému. Programátor je tak nucen napsat si mini roz¹íøení, které právì jím po¾adované vlastnosti zpøístupní. Poslední dùvod je pohodlnost. Proè pøepisovat celou ji¾ napsanou a navíc i odladìnou knihovnu do jiného jazyka, kdy¾ staèí zpøístupnit pouze její aplikaèní rozhraní (API). Velice dobrım pøíkladem takovıchto knihoven jsou binární roz¹íøení pro frameworky grafickıch u¾ivatelskıch rozhraní GTK\footnote{http://ruby-gnome2.sourceforge.jp/} a QT\footnote{http://rubyforge.org/projects/korundum/}.

Libovolnou knihovnu napsanou v jazyce C jako roz¹íøení pro skriptovací jazyk nelze pou¾ít pøímo, proto¾e by interpret nevìdìl, jak s ní má zacházet. Je potøeba napsat rozhraní mezi touto knihovnou a interpretem, které je zodpovìdné za dvì dùle¾ité èinnosti: (1) musí v interpretu registrovat nabízené funkce a tøídy knihovny a (2) musí poskytovat pøekladovou úroveò pro odli¹né volací konvence knihovny a interpretu. MRI napøíklad vy¾aduje u v¹ech funkcí volatelnıch z Ruby, aby pøijímaly a vracely pouze datovı typ \verb|VALUE| (popsán dále). Bì¾ná knihovna nic o specifickém datovém typu interpretu neví a u¾ vùbec netu¹í jak tøídu \verb|String| pøevést na reprezentaci øetìzce v jazyce C. Za tyto typové pøevody je takté¾ odpovìdné binární roz¹íøení.

Tvorbu binárních roz¹íøení lze v základu rozdìlit do dvou odli¹nıch postupù - do postupu automatického a manuálního. V dal¹ích odstavcích se ka¾dému pøístupu budu vìnovat více do detailu.

\subsubsection{Automatickı postup}
Pomocí speciálních nástrojù lze vrstvu mezi knihovnou a interpretem nechat vygenerovat automaticky. Pøíkladem mù¾e bıt projekt SWIG\footnote{http://www.swig.org/} (Simplified Wrapper and Interface Generator) slou¾ící pro automatickou tvorbu roz¹íøení pro knihovny napsané v jazyce C nebo C++. Seznam podporovanıch skriptovacích jazykù je úctyhodnı a mimo jiné zahrnuje známé jazyky jako Python, Perl, PHP nebo právì Ruby.

Pou¾ití podobnıch nástrojù je velice snádné. Vìt¹inou je bez slo¾ité a zdlouhavé konfigurace staèí spustit nad hlavièkovımi soubory zpøístup\v{n}ované knihovny. Jako vıstup vygenerují rozhraní, zdrojovı text v jazyce C nebo C++, kterı staèí u¾ jen pøelo¾it a poté nahrát v rámci programu vykonávaného v interpretu.

Vygenerované rozhraní zpravidla obsahuje pro ka¾dou nalezenou funkci knihovny jednu novì vygenerovanou funkci, která slou¾í jako pøekladovı obal. Vezme parametry pøedané interpretem a pøelo¾í datové typy do typù knihovny. Pro MRI je tøeba pøevést pøedané objekty do jejich reprezentací v jazyce C. Tedy pøevést objekt typu \verb|Fixnum| na \verb|int|, \verb|String| na \verb|char *|, atd... Poté zavolat obalovanou funkci knihovny a nakonec pøevést její návratovou hodnotu zpìt na Ruby objekt a vrátit ji interpretu. Rozhraní navíc obsahují jednu inicializaèní funkci, která v¹echny vygenerované obalovací funkce zaregistruje, aby byly v interpretu k dispozici.

Takto vygenerované rozhraní je velice pøímoèaré a programátor má minimální kontrolu nad jeho vıslednou podobou. Zpøístup\v{n}uje v¹echny funkce knihovny pro jejich volání ze skriptovacího jazyka se zachováním sémantiky jejich argumentù bez jakékoliv vy¹¹í abstrakce. Navíc zde mù¾e bıt problém se slo¾itımi vnitøními datovımi typy, které se pou¾ívají i vnì knihovny.

\subsubsection{Manuální postup}
Manuálním napsáním spojovací vrstvy získá programátor plnou kontrolu nad vısledkem. Jako jednu z hlavních vıhod vidím mo¾nost vytvoøit z vnitøních struktur pou¾ívanıch i vnì knihovny tøídy a z funkcí nad nimi operujícími metody této tøídy. Vısledkem je krásné objektové chování, jak jsou programátoøi v Ruby zvyklí na rozdíl od pouhého procedurálního zpøístup\v{n}ení v¹ech funkcí. Navíc není problém zapouzdøovanou knihovnu roz¹íøit o dal¹í funkcionalitu, která se u¾ ov¹em bude odehrávat pouze na úrovni Ruby.

Na druhou stranu má tento postup oproti automatickému pøístupu jednu znaènou nevıhodu\,--\,èas programátora. Ten musí nastudovat rozhraní knihovny, navrhnout jeho vhodné zapouzdøení a nakonec i celé rozhraní napsat. Díky èasové nároènosti se plnì manuální pøístup v praxi pou¾ívá pouze zøídka. Pokud je potøeba knihovnu je¹tì zapouzdøit na vy¹¹í úrovni, napøíklad adaptací na objektovı model, tak se spí¹e pou¾ívá kombinace obou pøístupù. Automaticky se vytvoøí rozhraní knihovny pøístupné ve skriptovacím jazyce a a¾ toto rozhraní se následnì zapouzdøí do objektù a dal¹ích specifickıch jazykovıch konstrukcí, které v jazyce C nebo C++ nejsou známy.

\subsubsection{Pøeklad roz¹íøení}
Vzhledem k faktu, ¾e binární roz¹íøení jsou psána ve stejném jazyce jako cílovı interpret skriptovacího jazyka, tak se velice podobnì i pøekládají. Ve vìt¹inì pøípadù jsou interprety napsány v jazycích C nebo C++, pøekládají se tedy do binární podoby pomocí programù z balíèku \verb|gcc|\footnote{http://gcc.gnu.org/}. Pøeklad bıvává øízen pøíkazem \verb|make|, podle pokynù uvedenıch v souboru \verb|Makefile|. Tento soubor bıvá vygenerován ze ¹ablon dodanıch programátorem za pomocí nástrojù z rodiny \verb|autotools|\footnote{http://www.gnu.org/software/hello/manual/automake/Autotools-Introduction.html} (napøíklad script \verb|configure|).

Binární roz¹íøení se pro MRI pøekládají také pomocí pøíkazu \verb|make|. Ov¹em na rozdíl od ostatních interpretù (i jinıch skriptovacích jazykù) není pou¾ita sada programù \verb|autotools|. \verb|Makefile| popisující, jak se má roz¹íøení pøelo¾it a nainstalovat toti¾ vygeneruje samo Ruby. Pro tyto úèely existuje modul \verb|mkmf|\footnote{http://ruby-doc.org/stdlib/libdoc/mkmf/rdoc/index.html} (MaKe MakeFile), pomocí jeho¾ metod programátor popí¹e na vysoké úrovni abstrakce, jak pøelo¾it jeho roz¹íøení a tento skript potom distribuuje spolu se zdrojovımi k\'{o}dy. Celı sled pøíkazù pro pøeklad a instalaci je zobrazen na Obrázku~\ref{ruby_rozsireni_fig1}.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
ruby extconf.rb   # vytvori makefile
make              # prelozi knihovnu
make install      # skopiruje knihovnu do systemu
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Pøeklad binárních roz¹íøení v Ruby.}
  \label{ruby_rozsireni_fig1}
\end{figure}

Modul \verb|mkmf| slou¾í hlavnì k nastavení dùle¾itıch cest pro pøeklad automaticky a nezávisle na dané verzi èi distribuci operaèního systému (cesta k hlavièkovım souborùm Ruby, jeho knihovnám). Mimo této èinnosti modul nabízí metody, které umo¾òují podobné èinnosti jako skript \verb|configure|\,--\,lokalizovat systémové knihovny, ovìøováním zda-li obsahují po\-¾a\-do\-va\-né symboly (funkce, promìnné, ...) a dal¹í podobnou funkcionalitu. Takto vytvoøenı skript je samozøejmì plnohodnotnı program v Ruby. Lze tedy pou¾ít ve¹keré jeho mo¾nosti vèetnì pou¾ití dal¹ích knihoven. Napøíklad lze distribuovat pouze skript bez zdrojovıch k\'{o}dù, kterı si prvnì stáhne nejnovìj¹í verzi projektu a a¾ poté bude pokraèovat ve své obvyklé èinnosti.

\subsubsection{Datovı typ VALUE}
\verb|VALUE| je datovı typ specifickı pro interpret  MRI. Ostatní implementace Ruby stejnì jako interprety úplnì jinıch skriptovacích jazykù ho neznají. V binárním roz¹íøení tento typ reprezujte Ruby objekt. V¹e je objekt, a proto se tento datovı typ pou¾ívá v¹ude\,--\,ka¾dá funkce volatelná z Ruby vrací \verb|VALUE| jako svou návratovou hodnotu. Ve skuteènosti se jedná o pøejmenování datového typu \verb|unsigned long| obsahujícího adresu struktury reprezentující danı objekt. Vìt¹inou se tedy jedná o prostı ukazatel. Ov¹em ne ve v¹ech pøípadech. Interpret vyu¾ívá faktu, ¾e ukazatele jsou na platformì x86 v pamìti zarovnány - nejni¾¹í dva bity jsou pro ukazatele v¾dy nulové (platí pro 32 bitovou architekturu, pro 64 bitù se zarovnává na 8 bytù - tedy poslední ètyøi bity ukazatele jsou nulové).

Napøíklad objekty tøídy \verb|Fixnum| (reprezentující celá èísla) nemají svou strukturu jako ostatní objekty, ale jejich hodnota je zak\'{o}dována pøímo do promìnné typu \verb|VALUE| tak, ¾e nultı bit (LSB, Least significant bit, nejménì vıznamnı bit) je nastaven na jednièku a ostatní bity jsou pou¾ity pro ulo¾ení vlastní hodnoty èísla. Tímto pøístupem se u¹etøí dereferencování ukazatele pøi práci s celımi èísly. Samozøejmì zobrazitelnı rozsah èísel je tímto pøístupem omezenı na 31 bitù (èíslo je ulo¾eno v pamìti jako znaménkové v dopl\v{n}kovém k\'{o}du). Proto Ruby pro pøíli¹ velká celá èísla nabízí je¹tì tøídu \verb|Bignum|, její¾ hodnota není reprezentována pøímo v místì ukazatele a nabízí podstatnì vìt¹í rozsah.

Tato optimalizace není pou¾ita jen u celıch èísel, ale také u singleton promìnnıch vıznamnıch a èasto pou¾ívanıch tøíd. Singleton je oznaèení pro tøídu, která má maximálnì jednu instanci v celém programu. V Ruby se jedná o instance tøíd \verb|TrueClass| (instance se jmenuje \verb|true|), \verb|FalseClass| (instancí je objekt \verb|false|) nebo \verb|NilClass| (instance je \verb|nil|, obdoba \verb|NULL| v jazyce C, ''prázdnı`` nebo také ''¾ádnı`` objekt). V¹echny tyto objekty nemají reprezentující strukturu, ale jejich obsah je pøímo zak\'{o}dován do typu \verb|VALUE| pro rychlej¹í interpretaci skriptu. Postup interpretu pøi interpretaci obsahu \verb|VALUE| je zobrazenı na Obrázku~\ref{fig_ruby_value_diagram}, kterı jsem pøevzal z pøíspìvku~\cite{webValue} o tomto datovém typu.

\begin{figure}[t]
  \centering
  \includegraphics[width=13.5cm,keepaspectratio]{./fig/ruby_value_diagram.png}
  \caption{Diagram pro reprezentaci hodnoty v promìné VALUE.}
  \label{fig_ruby_value_diagram}
\end{figure}

\section{Expertní systémy}
Jako jeden ze zpùsobù adresace problému lidského pøemı¹lení vznikly expertní systémy. Jedná se o systémy umìlé inteligence, které mají za cíl simulovat rozhodovací proces lidského experta. Tedy na základì ulo¾enıch znalostí a u¾ivatelskıch vstupù dojít k nìjakému závìru. Napøíklad expertní systém MYCIN~\cite{mycin}, vyvinutı na zaèátku 90. let minulého století, slou¾il jako vıpomoc lékaøùm k urèení diagnózy pacienta. Pomocí pokládání otázek typu ano/ne nakonec u¾ivatele informoval o jeho mo¾nıch diagnózách.

Expertní systémy neadresují problém univerzálního øe¹ení problému podobnì jako General problem solver~\cite{generalProblemSolver} (GPS). Místo toho po vzoru èlovìka, jeden konkrétní expertní systém umo¾òuje øe¹it problémy jen v urèité pøedem omezené oblasti vìdìní. Pou¾ívají se na místech, kde je obvyklé algoritmické øe¹ení nevhodné, slo¾ité, popøípadì tì¾ce udr¾ovatelné.

Zpravidla expertní systémy obsahují nìkolik èástí:

\textbf{Rozhodovací algoritmus.} Jádrem expertního systému v¾dy musí bıt rozhodovací algoritmus, kterı øídí celı proces rozhodování vedoucí od poèáteèních informací a¾ k dosa¾e\-né\-mu vısledku. Tento algoritmus je v¾dy spu¹tìn a¾ na ¾ádost u¾ivatele, poté, co skonèí se zadáváním úvodních informací. 

\textbf{Báze znalostí.} Báze znalostí reprezentuje znalosti ulo¾ené v expertním systému. Zpravidla má formu pravidel kdy¾-tak (if-then), které se skládají ze dvou èástí - levé a pravé strany. Levá strana obsahuje seznam podmínek, které musí platit pøed vykonáním samotného pravidla. Zatímco pravá strana zase obsahuje akce, které se mají vykonat po aktivaci pravidla. Tato pravidla umo¾òují mìnit, mazat a vyvozovat rùzné závìry z pracovní pamìti. Báze znalostí spolu s rozhodovacím algoritmem tvoøí nezbytnou souèást ka¾dého expertního systému.

\textbf{Pracovní pamì\v{t}.} Pracovní pamì» slou¾í k uchování aktuálnì známıch dat. Mù¾e také obsahovat vyvozené mezi závìry a nakonec zde také bude ulo¾en koneènı závìr, ke kterému expertní systém dojde. Jak zde data budou reprezentována zále¾í na daném expertním systému a nelze je pøíli¹ dobøe generalizovat podobnì jako v pøípadì báze znalostí.

\textbf{Vysvìtlující podsystém.} Dal¹í dùle¾itou ov¹em ji¾ nikoliv nezbytnou souèástí expertního systému je vysvìtlující podsystém. V mnoha pøípadech staèí lidskému u¾ivateli znát vısledek, ke kterému jeho expertní systém dospìl. V jinıch pøípadech je ov¹em dobré znát i jak a proè k nìmu do¹el. Napøíklad v dobì ladìní báze znalostí, je postup expertního systémù vedoucí k závìru naprosto nepostradatelnı.

\textbf{U¾ivatelské rozhraní.} Poslední hlavní souèástí expertních systému je u¾ivatelské rozhraní. Slou¾í k ovládání celého systému, tedy k zadávání známıch dat do pracovní pamìti a ovládání celého prostøedí\,--\,spu¹tìní rozhodovacího algoritmu a získaní vısledku. U nìkterıch expertních systému lze pøes u¾ivatelské rozhraní také upravovat bázi znalostí, ale to ji¾ zále¾í na konkrétním systému.

\subsection{CLIPS}
CLIPS je systém pro tvorbu expertních systémù napsanı v jazyce C vyvinutı v NASA na poèátku 90. let. V souèasné dobì je dostupnı jako public domain software a je tedy k dispozici zadarmo i pro komerèní vyu¾ití. Pùvodní autor Gary Riley se systému stále vìnuje a to jak opravováním nalezenıch chyb, tak i dal¹ím vıvojem.

CLIPS není expertním systémem, nıbr¾ se jedná o nástroj pro tvorbu expertních systémù. Z tohoto tì¾ko postøehnutelného rozdílu slov vyplıvá velice dùle¾itı fakt\,--\, CLIPS samo o sobì je díky absenci jakékoliv báze znalostí naprosto k nièemu. U¾ivatel CLIPS musí nejprve dodat bázi znalostí a a¾ poté se dá hovoøit o expertním systému, kterı lze pou¾ít k rozhodovaní. U¾ivatelské rozhraní je uzpùsobeno i pro snadnou manipulaci s bázi znalosti.

\subsection{U¾ivatelské rozhraní CLIPS}
U¾ivatelské rozhraní CLIPS umo¾òuje k ovládání celého prostøedí od manipulace s bázi znalostí pøes práci s pracovní pamìtí, a¾ po spu¹tìní rozhodovacího algoritmu. Rozhraním je specifickı programovací jazyk, kterı se strukturou velice podobá jazyku LISP. Mít vlastní programovací jazyk pro ovládání celého prostøedí má své vıhody i nevıhody. Vıhodou je nezávislost na vısledné podobì celkového u¾ivatelského rozhraní\,--\,mù¾e se jednat o formu pøíkazového øádku stejnì jako grafické okno oèekávající jednotlivé pøíkazy jazyka. Popøípadì CLIPS je¹tì umo¾òují nahrát a vykonat libovolnı textovı soubor, ve kterém mù¾e bıt ulo¾ena báze znalostí s vıchozí podobou pracovní pamìti. Na druhou stranu ov¹em tento pøístup má i velkou nevıhodu\,--\,u¾ivatel se musí nauèit zcela novı jazyk. Co¾ mù¾e pøiná¹et problémy, zvlá¹\v{t} má-li vıslednı expertní systém vyu¾ívat bì¾nì neprogramující obsluha.

V ukázkách u¾ivatelského rozhraní CLIPS budu pou¾ívat znak \verb|#| pro oddìlení kódu CLIPS od mého komentáøe. Tyto komentáøe ov¹em do ukázek samotnıch patøit nebudou.

\subsubsection{Datové typy u¾ivatelského rozhraní}
Ne¾ se dostanu k detailnìj¹ímu popisu mo¾ností samotného rozhraní, popí¹i datové typy, se kterımi vestavìnı programovací jazyk pracuje. Nejzákladnìj¹ím datovım typem je \verb|symbol|. Jedná se øetìzec velkıch nebo malıch písmen a podtr¾ítek èi pomlèek (podtr¾ítko ani pomlèka ov¹em nesmí bıt na první pozici). \verb|Symbol| se pou¾ívá na mnoha místech pro interní jména rùznıch CLIPS struktur. Podobnım datovım typem je \verb|øetìzec|, kterı se skládá s libovolné posloupnosti znakù uzavøené v uvozovkách. Obsahuje-li samotnı øetìzec znak pro uvozovky je potøeba ho o¹etøit tzv. escape sekvencí podobnì jako v jazyce C. Dále CLIPS rozli¹uje dva èíselné typy\,--\,jeden pro celá èísla a druhı pro desetinná èísla. Syntaxe jejich zápisu je shodná s jazykem C, proto je zde pro jejich slo¾itost nebudu hloubìji popisovat. Poslední datovı typ, kterı bych zde rád zmínil pro jeho pou¾ití v dal¹ím textu je \verb|fact_address|. Jedná se o referenci na vytvoøenı fakt v pracovní pamìti CLIPS. Tyto reference u¾ivatel sám explicitnì nevytváøí, ale jsou vytváøeny prostøedím a poskytnuta u¾ivateli k dal¹ímu zpracování. 

\subsubsection{Pracovní pamì\v{t}} \label{clips_working_memory}
Známé skuteènosti jsou v CLIPS reprezentovány pomocí tzv. faktù. Na fakta se lze dívat jako na tvrzení, na jejích¾ základì poté expertní systém odvozuje dal¹í nové skuteènosti. Tento popis je mo¾nı ve dvou základních typech faktù\,--\,seøazenıch a neseøazenıch.

Seøazenı fakt je vlastnì seznam rùznıch promìnnıch ulo¾enıch v pracovní pamìti CLIPS. Na první polo¾ku seznamu jsou kladena zvlá¹tní omezení\,--\,musí obsahovat symbol a musí bıt v¾dy pøítomna. Tato první polo¾ka je reprezentována jako jméno skupiny pøíbuznıch seøazenıch faktù. Poèet následujících polo¾ek je zcela libovolnı a ty mohou nabıvat libovolnıch datovıch typù mimo referencí.

Existují dva základní pøístupy k ukládání dat pomocí seøazeného faktu. Prvním je vytvoøení jednoho dlouhého faktu s pozièními polo¾kami pro v¹echny popisované skuteènosti. Tedy vıznam hodnoty je dán její pozicí v seøazeném faktu. Pøíklad tohoto pøístupu k ulo¾ení informací o èlovìku je na Obrázku~\ref{clips_ordered_fact}. Tento pøístup má nìkolik problémù. Jedním z nich je adresace problému prázdnıch hodnot. Fakt z pøíkladu sestává ze 4 uchovávanıch promìnnıch - jména, vìku, pohlaví a rodinného stavu. Problém nastane v pøípadì, ¾e nebudeme o dané osobì znát napøíklad vìk. Pak je otazné, co zde má bıt ulo¾eno, proto¾e vzhledem k poziènímu charakteru v¹ech hodnot musí bıt pozice obsazena. Proto je lep¹í ka¾dou sledovanou vlastnost dát do samostatného seøazeného faktu a spojovat je na základì jedné polo¾ky. V pøípadì neznalosti nìjaké hodnoty pak prostì fakt s chybìjící vlastností chybí celı. Pøepsanı pøíklad je zobrazen na Obrázku~\ref{clips_ordered_fact_2}. Tento druhı pøístup zvedá pamì\v{t}ovou nároènost vısledné aplikace, ov¹em na druhou stranu je optimalizovanìj¹í pro vnitøní implementaci rozhodovacího algoritmu, a proto bude dosahovat lep¹ích vıkonù. Dal¹ím problémem, kterı u¾ ov¹em seøazenı fakt øe¹it neumí, jsou omezení. Napøíklad je oèekávané, ¾e vìk bude èíselná hodnota, ov¹em do seøazeného faktu lze ulo¾it zcela libovolné hodnoty.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(clovek "Jaroslav Cecho" 22 muz svobodny)  
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Uchování dat v rámci jednoho dlouhého seøazeného faktu.}
  \label{clips_ordered_fact}
\end{figure}

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(clovek "Jaroslav Cecho")              # hlavni fakt
(vek "Jaroslav Cecho" 22)              # zavisle fakta spojuci
(pohlavi "Jaroslav Cecho" muz)         # hlavni fakt s urcitymi
(rodiny-stav "Jaroslav Cecho" svobodny)# uchovavanymi atributy
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Rozøezání sledovanıch hodnot do separátních seøazenıch faktù.}
  \label{clips_ordered_fact_2}
\end{figure}

Neseøazenı fakt lze pøirovnat ke strukturním promìnnım v jazyce C. Ty mají svùj typ identifikovanı jménem a poté seznam jednotlivıch polo¾ek. V CLIPS jsou neseøazené fakty vytváøené na základì ¹ablon a proto se jejich popisu budu vìnovat je¹tì pøed dal¹ím popisem neseøazenıch faktù. Jak vyplıvá z pøedcházejícího textu, ¹ablona je pøedpis obsahující pøednì seznam v¹ech mo¾nıch polo¾ek pro fakt. V terminologii CLIPS se polo¾ky nazıvají sloty. Jméno ¹ablony musí bıt unikátní, proto¾e se fakty vytváøejí za pou¾ití právì tohoto jména.

Ka¾dı slot musí mít své jméno, podobnì jako polo¾ky ve strukturách jazyka C. Na rozdíl od nich ov¹em je definice typu volitelná. Ve vıchozím stavu mù¾e slot pøijímat jakékoliv datové typy CLIPS. U¾ivatel mù¾e slotu volitelnì nastavit datovı typ, pøípadnì celou mno¾inu datovıch typù, které bude akceptovat. \u{C}ím¾ se dá vyøe¹it døíve uvedenı problém s ukládáním vìku osoby. Navíc mimo specifikace typu lze slot vytvoøit i s dal¹ími omezením. Pro èíselné sloty lze nastavit minimální i maximální akceptovanou hodnotu. Slot lze nastavit jako tzv. multislot, kterı smí obsahovat více ne¾ jednu hodnotu, popøípadì tomuto multislotu lze nastavit minimální i maximální poèet obsa¾enıch polo¾ek. Pøíklad vytvoøení ¹ablony pro popis èlovìka je na Obrázku~\ref{clips_template}.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(deftemplate clovek                    # sablona pro cloveka
  (slot name)                          # uchovavajici jmeno
  (slot vek (type INTEGER))            # vek
  (slot pohlavi)                       # pohlavi
  (slot rodiny-stav)                   # a rodiny stav
)
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{\v{S}ablona pro reprezentaci dat o èlovìku.}
  \label{clips_template}
\end{figure}

Na základì vytvoøené ¹ablony lze vytváøet u¾ jednotlivá neseøazená fakta. Zde je analogie se strukturní promìnou jazyka C stejná, prvnì se vytvoøí ¹ablona (struktura) a poté se mohou vytváøet její fakta (promìnné s typem vytvoøené struktury). První hodnota vytváøeného faktu musí bıt jméno ji¾ vytvoøené struktury následované seznamem slotù s jejich hodnotami. 

Neseøazená fakta mají nìkolik vıhod oproti seøazenım faktùm, pøednì zapouzdøují data tıkající se jedné popisované entity dohromady (v mıch pøíkladech se jedná o popis èlovìka). Dále, jak jsem uvedl v popisu ¹ablony, jednotlivé sloty lze omezit na akceptované hodnoty, co¾ umo¾òuje mít èistı a kontrolovanı návrh. Neseøazené fakta také øe¹í problém neznámıch hodnot - nezadané sloty jsou neznáme a nemusí se zde ukládat ¾ádná hodnota znaèící ''nic``. Pøíklad neseøazeného faktu je na Obrázku~\ref{clips_nonordered_fact}.
 
\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(clovek                                # serazeny fakt
  (name "Jaroslav Cecho")              # s vyplnenymi sloty
  (vek 22)
  (pohlavi muz)
)
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Neseøazenı fakt popisující èlovìka.}
  \label{clips_nonordered_fact}
\end{figure}

V CLIPS se fakta v pracovní pamìti vytváøejí pomocí funkce \verb|assert|. Pøíklady ulo¾ení faktu do pracovní pamìti CLIPS jsou na Obrázku~\ref{clips_assert}. Jak jde v ukázce vidìt, funkce se volá úplnì stejnì jak pro neseøazenı, tak i pro seøazenı fakt. Pro variantu seøazeného faktu ov¹em ¹ablona jména \verb|clovek| ji¾ musí existovat jinak ukázka skonèí chybou. Mazání fakt z pracovní pamìti probíhá voláním funkce \verb|retract|, která jako parametr pøijímá referenci na fakt. Postup k získání reference na fakt bude vysvìtlen v kapitole~\ref{clips_knowledge_base}. Poslední mo¾ná operace s fakty je jejich zmìna, pro kterou se pou¾ívá funkce \verb|modify|, která opìt oèekává referenci na fakt jako svùj parametr.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(assert (neserazeny-clovek "Jaroslav Cecho" 22 muz))
(assert (clovek (name "Jaroslav Cecho") (vek 22) (pohlavi muz)))
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Vytváøení faktù v pracovní pamìti.}
  \label{clips_assert}
\end{figure}

Je¹tì bych se rád vìnoval vnitøní implementaci rozdílu seøazenıch a neseøazenıch faktù v CLIPS. Na té nejni¾¹í úrovni jsou toti¾ i pro seøazená fakta vytváøené ¹ablony s právì jedním multislotem jménem \verb|implied|. První hodnota seøazeného faktu slou¾í jako jméno automaticky vytvoøené ¹ablony. Celé chovaní je samozøejmì vy¹¹ími vrstvami CLIPS zapouzdøeno a u¾ivatel si tak nemusí bıt vìdom tohoto chování. Tento pøístup s sebou ov¹em pøiná¹í jednu nevıhodu. Jméno ¹ablony musí bıt v rámci systému unikátní a první hodnota seøazenıch faktù slou¾í právì jako jméno ¹ablony. Nelze tedy vytvoøit ¹ablonu a skupinu seøazenıch faktù stejného jméno, co¾ vzhledem k odli¹nému vıskytu mù¾e u¾ivateli zpùsobit zmatení. Není na první pohled hned viditelné, ¾e se obì tato jména vybírají ze stejné mno¾iny. Popisovanı problém lze obejít pou¾ívání právì jednoho typu faktu v jedné aplikaci.

\subsubsection{Báze znalostí} \label{clips_knowledge_base}
CLIPS podobnì jako mnoho dal¹ích expertních systémù pou¾ívá pro reprezentaci báze znalostí pravidla typu kdy¾-tak (if-then). Pravidla fungují na principu vyhledávání vzorù na mno¾inì existujících faktù. Levá strana pravidla proto obsahuje v¹echny vzory, které musí bıt nalezeny pro aktivaci pravidla. Pravá strana poté obsahuje seznam èinností, které se mají stát po aktivaci pravidla. V rámci aktivace pravidel lze provádìt mnoho rùznıch èinností jako napøíklad vypisování nalezenıch informací, ov¹em nejdùle¾itìj¹í operace se tıkají manipulace s fakty. Ta lze modifikovat, vytváøet èi mazat.

Nejdøíve se budu blí¾eji vìnovat mo¾nostem levé strany pravidla. Jak ji¾ bylo øeèeno, levá strana obsahuje vyhledávané vzory. Z tohoto dùvodu je zde seznam faktù, které musí existovat. CLIPS zde nemá ¾ádné restrikce a lze libovolnì míchat seøazená a neseøazená fakta. Zápis se neli¹í od bì¾ného zápisu faktu a¾ na mo¾nost místo libovolné hodnoty mimo ¹ablony nebo skupiny podobnıch seøazenıch faktù zadat promìnnou. Ta zaèíná znakem otazníku následovaného jménem promìnné. Opravdová síla promìnnıch se projeví a¾ kdy¾ je pou¾ita stejná promìnná na více místech v rámci jednoho pravidla. Proto¾e v¹echny promìnné stejného jména jsou nahrazeny stejnou hodnotou, èeho¾ se vyu¾ívá pøi vyhledávání faktù se stejnımi ov¹em pøedem neznámımi hodnotami velice podobnì jako v jazyce PROLOG~\cite{prolog}. Na Obrázku~\ref{clips_rule_1} je ukázka pravidla obsahující pouze levou stranou, na kterém mimo jiné prezentuji zápis promìnnıch. Pokud bude v systému vyhovovat danému vyhledávanému vzoru více mo¾nıch kombinací faktù, tak to stejné pravidlo bude zavoláno vícekrát\,--\,jednou pro ka¾dou mo¾nou kombinaci.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(defrule pouze-leva-strana            # pravidlo s levou stranou
  (neserazeny-fakt ?promena)          # hledajici dve fakta se 
  (serzeny-fakt (prvni-slot ?promena))# stejnou promenou
-> )
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Vytvoøení pravidla obsahující pouze levou stranou.}
  \label{clips_rule_1}
\end{figure}

Je-li na levé stranì pravidla uvedeno více hledanıch faktù, je mezi nì polo¾ena logická spojka ''a souèasnì`` (and). Pravidlo bude aktivováno právì tehdy, kdy¾ budou v systému pøítomny v¹echny fakta. Pro jemnìj¹í nastavení podmínek aktivace CLIPS umo¾òuje pou¾ívat i ostatní logické spojky - ''nebo`` a negaci. Jejich pou¾ití je zobrazeno na Obrázku~\ref{clips_rule_2}. Pravidlo z pøíkladu bude aktivovano pro ka¾dou dvojici faktù \verb|prvni| a \verb|treti|, \verb|druhy| a \verb|treti|, které mají stejnou druhou hodnotu.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(defrule logicke-spojky               # pravidlo se spojkami
  (or
    (prvni ?promena)                  # jeden z techto faktu
    (druhy ?promena)                  # musi byt pritomen
  )
  (treti ?promena)                    # tento ovsem vzdy
-> )
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Vytvoøení pravidla s logickımi spojkami.}
  \label{clips_rule_2}
\end{figure}

Reference na nalezená fakta, díky kterıch do¹lo k aktivaci pravidla, se dají v CLIPS ulo¾it do promìnné. Na rozdíl od promìnnıch prezentovanıch vı¹e, zde u¾ neplatí, ¾e více vıskytù se nahradí právì jednou hodnotou. Pokud se u¾ivatel do promìnné rozhodne ulo¾it referenci na aktivaèní fakt, promìnou tohoto jména v rámci levé strany ji¾ nelze pou¾ít. Pøíklad zápisu ulo¾ení reference na aktivní fakt je na Obrázku~\ref{clips_rule_3}.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(defrule reference-na-fakt
  ?ref <- (fakt ktery se ma najit)    # uchovej referenci
-> )
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ulo¾ení reference na aktivaèní fakt.}
  \label{clips_rule_3}
\end{figure}

Jak ji¾ bylo uvedeno vı¹e, pravá strana pravidla slou¾í k popsání vìcí, které se mají stát po aktivaci pravidla. Lze zde volat libovolné funkce CLIPS, ov¹em já se omezím na popis manipulace s fakty. Na pravé stranì lze vytváøet fakta úplnì stejnì jako jinde v systému, tedy pomocí pou¾ití funkce \verb|assert|. Navíc lze místo pøesnıch hodnot pou¾ít promìnné získané z levé strany pravidla (s vıjimkou promìnnıch referencujících fakta). Dal¹ími mo¾nostmi je aktivaèní fakta mazat pomocí funkce \verb|retract| nebo je mìnit pomocí funkce \verb|modify|. Pøíklady pou¾ití v¹ech tøí funkcí jsou na Obrázku~\ref{clips_rule_4}.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
(defrule prava-strana
  ?ref1 <- (prvni ?prom ?x)
  ?ref2 <- (clovek (name ?name) (nickname ?nick))
  ->
  (assert (treti ?x))                           # vytvor novy fakt
  (retract ?ref1)                               # vymaz prvni fakt
  (modify ?ref2 (nickname ?name) (name ?nick) ) # zmen druhy fakt
)
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ukázka pravé strany pravidla.}
  \label{clips_rule_4}
\end{figure}

\subsection{Prostøedí v CLIPS}
V rámci jedné instance CLIPS lze provozovat více nezávislıch expertních systémù. Tato funkcionalita je umo¾nìna tzv. prostøedími. Prostøedí je název pro zcela oddìlenou èást systému, která má vlastní bázi znalostí i pracovní pamì». Rozhodovací algoritmus musí bıt pro ka¾dé prostøedí spu¹tìn samostatnì. Vyu¾ívají se v pøípadì, ¾e u¾ivatel nechce z urèitého dùvodu bì¾et více procesù v operaèním systému.

\subsection{Roz¹iøitelnost}
Podobnì jako lze binárními roz¹íøeními pøidat do interpretu skriptovacího jazyka dal¹í funkcionalitu, i CLIPS lze roz¹íøit o nové funkce. Aplikaèní rozhraní CLIPS umo¾òuje u¾ivateli zaregistrovat libovolnou novou funkci a poté ji z u¾ivatelského rozhraní volat. Oproti roz¹íøením interpretu mají roz¹íøení CLIPS velké omezení. Nelze je nahrávat za bìhu, tak jako v Ruby pomocí pøíkazu \verb|require|. Musí tedy bıt do CLIPS pøidány ji¾ v dobì kompilace. V ostatních ohledech se ov¹em chovají stejnì a øe¹í stejné problémy jako ony. Jsou odpovìdné za pøevody typù a volajících konvencí mezi CLIPS a spojovanımi knihovnami.

\subsection{Rozhodovací algoritmus}
Jak jsem ji¾ zmínil v pøedchozích odstavcích, rozhodovací algoritmus CLIPS funguje na základì vyhledávání vzorù na mno¾inì v¹ech faktù pøítomnıch v systému. Jedním z mo¾nıch zpùsobu nalezení v¹ech mo¾nıch pravidel k aktivaci i spolu se v¹emi aktivaèními parametry je sekvenèní prùchod existujících faktù. Tato naivní implementace by u¾ pro systémy se stovkami faktù byla pøíli¹ pomalá a proto CLIPS vyu¾ívá algoritmu optimalizovaného pro vyhledávání vzorù\,--\,algoritmus Rete~\cite{expertSystems} (Rete algorithm).

Detailní popis algoritmu je nad rámec této práce, proto zde uvedu pouze nástin jeho principu. V pamìti vytváøí stromovou strukturu, kde ka¾dı uzel mimo koøene odpovídá jednomu hledanému vzoru nìjakého pravidla. Bude-li mít pravidlo celkem tøi vyhledávané vzory, poté bude celé pravidlo reprezentované celkem tøemi uzly. Cesta od koøene k listu odpovídá celé levé stranì pravidla. V ka¾dém uzlu bude ulo¾en ukazatel na fakta, které danı vzor spl\v{n}ují. V listech stromu poté fakta vyhovující pro aktivaci pravidla, jeho¾ levá strana je ve stromu reprezentována. Jak jsou jednotlivé fakta vytváøena èi modifikována, tak se propagují do tohoto stromu a pøi ulo¾ení a¾ do nìjakého listu mohou zpùsobit aktivaci pravidla.

%=========================================================================
\chapter{Knihovna rbClips}
%=========================================================================
V této kapitole se ji¾ dùkladnì budu vìnovat své vlastní prací\,--\,knihovnì rbClips. Pos\-tupnì v následujících podkapitolách popí¹i její návrh, nìkteré zajímavé implementaèní detaily a samozøejmì nevynechám shrnutı popis aplikaèního rozhraní. \'{U}plné detaily rozhraní u¾ ov¹em ponechám do programové dokumentace. V závìru kapitoly je uveden praktickı pøíklad pou¾ití knihovny.

\section{Po¾adavky}
Cílem této prace a tedy i hlavním po¾adavkem je vytvoøit knihovnu zpøístup\v{n}ující funkce CLIPS v jazyce Ruby. A to nikoliv jako automaticky vytvoøené roz¹íøení, které pouze zpøístupní funkce CLIPS. Musí nabídnout u¾ivateli rozhraní, které bude objektové a bude v souladu s nepsanımi konvencemi jazyka Ruby. Je vy¾adováno zapouzdøit celou knihovnu do objektù a odstínit tak u¾ivatele od nutnosti znát syntaxi u¾ivatelského rozhraní CLIPS. Dále je nutné umo¾nit u¾ivateli v rámci aktivace pravidla volat libovolné metody Ruby a tím v rámci vytváøeného expertního systému zpøístupnit celou ¹kálu dal¹ích ji¾ existujících knihoven Ruby.

\section{Návrh}
Aplikaèní rozhraní popsané v kapitole~\ref{rbclips_api} jsem navrhl po vzoru open source knihovny ActiveRecords (AR). Stejnì jako AR odsti\v{n}uje programátora od nutnosti znát SQL, tak i rbClips odstin\v{n}uje programátora od nutnosti znát programovací jazyk u¾ivatelského rozhraní CLIPS. Ve¹kerá funkcionalita je zapouzdøena do objektù a ovládá se pomocí metod tìchto objektù. Hlavní dùvod proè jsem rozhraní navrhl po vzoru AR je jeho velká roz¹íøenost. Jakıkoliv programátor, kterı alespo\v{n} èásteèné zná rozhraní AR, se v rbClips velice rychle zorientuje a nebude mít pøíli¹ velké problémy mou knihovnu zaèít pou¾ívat.

Celá knihovna je zapouzdøena v jednom Ruby modulu jménem \verb|Clips|. Ten obsahuje pìt hlavních tøíd: \verb|Fact|, \verb|Template|, \verb|Rule|, \verb|Environment|, \verb|Constraint|, které popisují pøíslu¹né entity v CLIPS a zapouzdøují celou práci s nimi. Dále obsahuje nìkolik pomocnıch tøíd, které u¾ivatel není oprávnìn vytváøet pøímo. Dostává je jako ji¾ vytvoøené objekty do konfiguraèních blokù hlavních tøíd. Tyto pomocné tøídy budou upøesnìny dále v textu v popisu jednotlivıch hlavních tøíd, kde jsou pou¾ívány. Nakonec obsahuje je¹\v{t}e modul \verb|Base| slou¾ící pro volání dùle¾itıch funkcí CLIPS, které nejsou souèástí jinıch velkıch entit. Seznam hlavních tøíd a modulù je vyobrazen na Obrázku

Inspirace AR se projevila i v urèitıch návrhovıch vzorech, které jsou shodné napøíè celım API. Mimo vıjimek zmínìnıch u popisu konkretních tøíd ní¾e, obsahují v¹echny tøídy spoleènou podmno¾inu metod zobrazenou na Obrázku~\ref{common_methods}. Entita zastupuje libovolnou hlavní tøídu knihovny rbClips, dvojznak \verb|::| pøíslu¹í tøídní metodì, zatímco znak \verb|#| patøí instanèní metodì. Inspirace AR není vidìt jen u tìchto spoleènıch metod, ale také v chování celé knihovny. Napøíklad vytvoøení instance tøídy \verb|Fact|, \verb|Rule| nebo \verb|Template| automaticky nevytvoøí odpovídající novou entitu i v prostøedí CLIPS. K vytvoøení (ulo¾ení) entity v prostøedí CLIPS dojde a¾ v okam¾iku zavoláním metody \verb|save|. Velice podobnì to funguje i s aktualizací entit, ve¹keré zmìny je potøeba potvrdit opìtovnım voláním metody \verb|save|, jinak se zmìny v prostøedí CLIPS nikdy neobjeví. Tato funkcionalita lze pøirovnat k operaci \verb|commit| z transakèního zpracování jazyka SQL.

\begin{figure}[t]
  \centering
  \includegraphics[width=10.6cm,keepaspectratio]{fig/class_diagram.png}
  \caption{Modul Clips a jeho hlavní tøídy.}
  \label{rbclips_class_design}
\end{figure}

\begin{figure}[t]
\begin{itemize}
 \item \verb|Entita#save| Vytváøené entity nejsou po vzoru ActiveRecords do CLIPS ulo¾eny automaticky pøi vzniku objektu, ale je tøeba je explicitnì ulo¾it pomocí metody \verb|save|. Velice podobnì se knihovna chová i pøípadì editace entity, napøíklad zmìna hodnoty slotu nìjakého faktu, která takté¾ vy¾aduje volání metody \verb|save| k ulo¾ení i do CLIPS.

 \item \verb|Entita#saved?| Metoda \verb|saved?| slou¾í ke zji¹tìní zda-li je daná entita ulo¾ena v CLIPS. Po ulo¾ení entity do CLIPS slou¾í ke zji¹tìní zda-li je reprezentace entity v Ruby objektu shodná s jeho reprezentací v CLIPS. Má dvì mo¾né návratové hodnoty\,--\,\verb|true| a \verb|false|.

 \item \verb|Entita#destroy!| Pro vymazání entity z CLIPS slou¾í metoda \verb|destroy!|. V pøípadì úspì¹ného vymazání vrací \verb|true|, pokud ji¾ daná entita v CLIPS neexistuje a nelze tedy vymazat, tak vrací \verb|false|. V obou pøípadech je pouze vymazána reprezentace v CLIPS, samotnı Ruby objekt je ponechán nedotèen a lze ho tedy bez problému znovu ulo¾it. V pøípadì problému s vymazáním metoda vyhazuje vıjimku pøíslu¹ného typu, napøíklad nelze smazat ¹ablonu, kterou souèasnì pou¾ívají nìkterá neseøazená fakta.

 \item \verb|Entita#update| Pokud u¾ivatel provede na aktuálním objektu zmìny, kterıch se chce zbavit a obnovit pùvodní ulo¾enou podobu z CLIPS, tak mù¾e pou¾ít metodu \verb|update|. Tato metoda neslou¾í pro ulo¾ení pøípadnıch zmìn do CLIPS, ale v¾dy pouze k aktualizování hodnot v Ruby objektu z CLIPS.

 \item \verb|Entita::all| Vrátí pole v¹ech entit daného typu, které se aktuálnì nacházejí v aktivním prostøedí CLIPS. 

 \item \verb|Entita::load| Vrátí jednu nebo více entit dle pøedanıch kritérii. Jako parametr bere v pøípadì tøíd \verb|Template| a \verb|Rule| jméno hledané entity, tedy parametr tøídy \verb|String| a vrací právì jednu nalezenou instance pøípadnì \verb|nil|. Pro tøídu \verb|Fact| akceptuje o dost ¹ir¹í mo¾ností argumentù, které zde nebudu zbyteènì opisovat z programové dokumentace.

\end{itemize}
 
  \caption{Spoleèná podmno¾ina metod vìt¹iny tøíd knihovny rbClips.}
  \label{common_methods}
\end{figure}

\section{Aplikaèní rozhraní knihovny} \label{rbclips_api}
V následujících odstavcích se budu detailnìji vìnovat jednotlivım hlavním tøídám v knihovnì rbClips. Ní¾e uvedenı popis nepokrıvá ve¹kerou nabízenou funkcionalitu, ale vyzdvihuje základní pou¾ití a upozor\v{n}uje u¾ivatele na pøípadné záludnosti. Zbıvající èásti jsou popsány v programové dokumentaci.

\subsection{Modul Base}
CLIPS je celé prostøedí pro tvorbu expertních systémù, nikoliv jen knihovna pro tvorbu faktù, pravidel a dal¹ích vìt¹ích entit. Proto obsahuje také velké mno¾ství rùznıch dopl\v{n}ko\-vıch funkcí, které prostøedí umo¾òují ovládat. Právì pro tyto funkce existuje modul \verb|Base|, kde jsou pohromadì metody, které se nedotıkají ¾ádného vìt¹ího celku CLIPS pokrytého hlavními tøídami, ale nelze si bez nich vıslednı expertní systém pøedstavit. Dále uvedu dvì nejdùle¾itìj¹í metody, se kterımi se u¾ivatel mé knihovny mù¾e setkat:

\textbf{run(FixNum)} Metoda \verb|run| slou¾í k zahájení aplikace pravidel. Bì¾nı postup spu¹tìní programu v CLIPS sestává z vytvoøení mno¾iny pravidel a prvotních faktù a následného spu¹tìní vlastního algoritmu pro jejich zpracování. Knihovna rbClips na tomto pøístupu nic nezmìnila, proto se do zavolání metody \verb|run| ¾ádná pravidla neaplikují. Pro zamezení pøípadného nekoneèného cyklu slou¾í volitelnı argument urèující maximální poèet pravidel, která se smí aplikovat. Návratovou hodnotou je celkovı poèet aplikovanıch pravidel (jedno pravidlo mù¾e bıt aktivováno a tedy i zapoèítáno vícekrát).

\textbf{insert\_command(String)} Knihovna rbClips zapouzdøuje nejpou¾ívanìj¹í èásti CLIPS, bohu¾el ov¹em ne ve¹kerou mo¾nou funkcionalitu. Kvùli absenci 100\% po\-kry\-tí v¹ech mo¾ností CLIPS jsem vytvoøil metodu \verb|insert_command|. Na vstupu metoda dostává jako parametr jeden validní pøíkaz CLIPS, kterı následnì provede a vrací objekt \verb|true| nebo \verb|false| podle úspìchu vykonání. Kvùlí chování funkcí, které jsou v prostøedí CLIPS nakonec zavolány, je pro správnou funkènost nutné, aby pøedanı øetìzec obsahoval maximálnì jeden pøíkaz. V pøípadì, ¾e jich bude obsahovat více, tak se provede pouze první z nich. Navíc se do Ruby vrátí informace, ¾e v¹e probìhlo v poøádku, co¾ mù¾e bıt velice matoucí.

\subsection{Tøída Environment}
Tøída \verb|Environment| slou¾í pro vytváøení a manipulaci s CLIPS prostøedími. Pomocí ní¾e zmínìnıch API knihovny se v¾dy nastaví jedno prostøedí jako aktivní a v¹echna pravidla a fakta jsou do nìj ulo¾ena. Po startu programu je jedno prostøedí vytvoøeno automaticky, aby ho u¾ivatel nemusel v¾dy vytváøet explicitnì.

RbClips vyu¾ívá mo¾ností, které CLIPS pro prostøedí nabízí, a proto se chová bohu¾el mírnì neobjektovì. V jeden okam¾ik mù¾e bıt aktivní pouze jedno prostøedí a to i v pøípadì více vláknové aplikace. Navíc je potøeba u vícevláknovıch aplikací dávat pozor na potencionálnì nebezpeèné volání \verb|Environment::new|. CLIPS novì vytvoøené prostøedí rovnou nastaví jako aktuální, co¾ poru¹uje konvence rbClips. Prostøedí se stává aktivní a¾ po zavolání metody \verb|set_current| (obdoba metody \verb|save| z ostatních hlavních tøíd). Volání konstruktoru tøídy tedy vytvoøí nové prostøedí, a poté pøepne zpìt do starého prostøedí. Toto pøehazování je nebezpeèné právì ve více vláknovıch aplikacích, kde mohou nastat tì¾ko odhalitelné èasovì závislé chyby nad daty. Napøíklad se ukládaná pravidla èi fakta mohou ulo¾it do zdánlivì náhodnì zvolenıch jinıch prostøedí. Z tohoto dùvodu doporuèuji vytvoøit v¹echna potøebná prostøedí je¹tì pøed samotnım vytvoøením vláken.

Ukázka práce s prostøedími je uvedena na Obrázku~\ref{rbclips_example_environment}.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
include Clips
env = Environment.new         # vytvori nove prostredi
cur = Environment.current     # vrati aktualni prostredi
env.set_current               # nastavi aktualni prostredi
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Pøíklad pou¾ití tøídy Environment.}
  \label{rbclips_example_environment}
\end{figure}

\subsection{Tøída Constraint}
Druhá hlavní tøída \verb|Constrait| zapouzdøuje kompletní práci s omezeními pro sloty ne\-se\-øa\-ze\-nıch faktù. Vytvoøení omezení je snadné, konstruktor akceptuje jako parametr jedno asociativní pole se ètyømi mo¾nımi klíèi. První mo¾nost klíè \verb|:type| jako hodnotu akceptuje jeden nebo pole mo¾nıch typù. Typy jsou reprezentovanı symboly a smí nabıvat hodnot \verb|:symbol|, \verb|:string|, \verb|:lexeme|, \verb|:integer|, \verb|:float|, \verb|:number|, \verb|:instance_name|, \verb|:instance_address|, \verb|:instance|, \verb|:external_address|, \verb|:fact_address| pøípadnì hodnoty \verb|:any| reprezentující jakıkoliv datovı typ (implicitní hodnota). Druhı mo¾nı klíè je \verb|:values| akceptující jednu èi pole v¹ech rùznıch hodnot, kterıch slot s tímto omezením smí nabıvat. Poslední dva klíèe \verb|:range| a \verb|:cardinatily| akceptují Ruby objekt tøídy \verb|Interval|. Klíè \verb|:cardinality| omezuje poèet mo¾nıch hodnot v multislotech, zatímco \verb|:range| omezuje mo¾né velikosti ulo¾itelnıch èísel.

Pro názornìj¹í pochopení je na Obrázku~\ref{rbclips_example_constraint} uveden pøíklad, kterı vytváøí dvì rùzná omezení. Slot s omezením objektu \verb|a| bude moci obsahovat pouze hodnoty typu \verb|øetìzec| nebo \verb|symbol|. Druhı pøíklad, objekt \verb|b|, nastavuje slotu povolení pouze pro celá èísla v rozsahu 3 a¾ 13.

Uvnitø CLIPS bohu¾el neexistuje mo¾nost, jak mno¾inu omezení ulo¾it jako samostatnou entitu. Omezení je v¾dy ulo¾eno pouze v rámci jednotlivıch slotù vytváøenıch ¹ablon. Z~tohoto dùvodu v knihovnì rbClips objekty tøídy \verb|Constraint| nemají metodu \verb|save| a nejdou tedy ani ulo¾it. Existují pouze na úrovni interpretu Ruby. Pokud programátor nastaví nìjakému slotu omezení, vezme se jeho aktuální stav a ten se pou¾ije. Pokud je tento \verb|Constraint| objekt posléze zmìnìn, tak se zmìny ji¾ zpìtnì nepromítnou do v¹ech míst, kde byl pou¾it. Proto je vhodné vytvoøit v¹echny objekty popisující omezení na zaèátku programu je¹tì pøed tvorbou ¹ablon a dále je pokud mo¾no ji¾ nemìnit.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
a = Constraint.new :type => [:string, :symbol]
b = Constraint.new :type => :integer, :range => 3..13
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Pøíklad pou¾ití tøídy Constraint.}
  \label{rbclips_example_constraint}
\end{figure}

\subsection{Tøída Template}
Tøída \verb|Template| slou¾í pro práci s CLIPS ¹ablonami. Vytvoøit ¹ablonu lze dvìma základními postupy. Konstruktor akceptuje bu\v{d} konfiguraèní asociativní pole nebo jméno ¹ablony s konfiguraèním blokem. V pøípadì konfigurace u¾itím asociativního pole, musí toto pole obsahovat povinnì dva klíèe - \verb|:name| a \verb|:slots|. Klíè \verb|:name| slou¾í pro zadání jména ¹ablony, které musí bıt v daném prostøedí unikátní. Druhı po¾adovanı klíè \verb|:slots| slou¾í jako seznam slotù vytváøené ¹ablony. Akceptuje jako hodnotu bu\v{d} pole objektù tøídy \verb|String| nebo \verb|Symbol|, které bude reprezentováno jako jména jednotlivıch slotù. V pøípadì, kdy u¾ivatel potøebuje zmìnit slotùm vıchozí chování, je pro nìj nachystána druhá varianta klíèe \verb|:slots|, která pøijímá dal¹í (ji¾ tedy vnoøené) asociativní pole. Klíèi tohoto vnoøeného pole jsou jména slotù, pøièem¾ hodnotami je v poøadí ji¾ tøetí asociativní pole, které obsahuje seznam atributù daného slotu. Atributy slotù existují dva: \verb|:multislot| povolující ulo¾ení více hodnot v rámci jednoho slotu a \verb|:default| obsahující vıchozí hodnotu (implicitnì \verb|nil|).

Zápis u¾ívající postupnì tøi vnoøená asociativní pole není zrovna pro èlovìka pøehlednı, proto existuje druhá, o dost èitelnìj¹í varianta volání konstruktoru u¾itím bloku. Konfiguraèní blok bude zavolán s jednou promìnou pomocné tøídy \verb|TemplateCreator|, která má metodu \verb|slot| slou¾ící pro vytvoøení nového slotu. Jméno slotu je pøedáno jako první argument. Volitelnì lze jako druhı argument pøedat asociativní pole popisující atributy slotu (tedy to samé asociativní pole, které se pøedává jako druhé vnoøené pøi první variantì volání konstruktoru). Oba postupy jsou zobrazeny na Obrázku~\ref{rbclips_example_template}.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
# tvorba sablony pomoci asociativniho pole
Template.new :name => 'animal', :slots => %w(name age race)

# tvorba samlony pomoci bloku
Template.new 'animal' do |t|
  t.slot :name            # vytvor slot "name"
  t.slot :age             # vytvor slot "age"
  t.slot :race            # vytvor slot "race"
end
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Dvì mo¾nosti tvorby stejné ¹ablony.}
  \label{rbclips_example_template}
\end{figure}

\subsection{Tøída Fact}\label{rbclips_facts}
Jak bylo uvedeno v kapitole~\ref{clips_working_memory} CLIPS rozli¹ují dva typy faktù - seøazené a neseøazené. Díky velice podobné vnitøní implementaci obou druhù faktù v CLIPS, jsem je oba zapouzdøil do jediné Ruby tøídy jménem \verb|Fact|. Vìt¹ína rozhraní této tøídy je shodná pro oba typy faktù, ale samozøejmì existují èásti, ve kterıch se API li¹í.

Podobnì jako celé rozhraní rbClips i zmìna obsahu faktù je navr¾eno po vzoru ActiveRecords. Programátora AR tedy nepøekvapí, ¾e zmìny faktù se neprojeví v CLIPS okam¾itì, ale jsou jen lokálnì ulo¾eny v instanci tøídy. A¾ po zavolání metody \verb|save| se v¹e ulo¾í. Bohu¾el CLIPS se ke zmìnì faktu chová velice neprakticky\,--\,místo zmìnìní jednotlivıch atributù se aktualizovanı fakt prvnì vyma¾e, a poté se vlo¾í novı s ji¾ aktualizovanımi hodnotami. Samozøejmì toto probíhá jako jedna atomická operace. Tedy nenastane stav, kdy by zbytek systému mohl postøehnout, ¾e jeden fakt byl vymazán a novı je¹tì nevlo¾en. Pro rbClips to ov¹em znamená obrovskı problém. Instance tøídy si udr¾uje ukazatel na strukturu faktu v CLIPS a aktualizací se tento ukazatel stává neplatnım. Objekt je tedy po aktualizaci ji¾ vlastnì neulo¾enı (jeho vnitøní ukazatel neukazuje na neplatnı fakt). Tento neduh se mi nepodaøilo opravit tak, abych nerozbil jinou, ji¾ napsanou funkcionalitu, pøípadnì budoucí plány s roz¹íøením podpory pro vícevláknové aplikace. Proto je na u¾ivateli rbClips, aby zajistil, ¾e aktualizaci provede a¾ v momentì, kdy u¾ danı fakt nebude potøeba nadále mìnit. Ze zku¹enosti z pou¾ívání AR, které je pøedlohou rozhraní, si myslím, ¾e to nebude a¾ takovı problém dodr¾et.

\subsubsection{Seøazenı fakt}
Na následujících pár øádcích bych rád popsal metody specifické pro seøazenı fakt. Rozhraní tøídy Fact je ov¹em optimalizované hlavnì pro neseøazené fakty, proto¾e ty obsahují více mo¾ností pro èist¹í návrh rozhraní. Z tohoto dùvodu bych doporuèil pou¾ívat radìji neseøazenou variantu faktu.

V seøazené variantì faktu knihovna rbClips uchovává pole hodnot, které je vrací metoda \verb|slots|. První atribut neseøazeného faktu není ve vráceném poli obsa¾en, proto¾e se k nìmu CLIPS chovají jako ke jménu skupiny faktù. Jak ji¾ bylo zmínìno vı¹e, ve skuteènosti se jedná o jméno automaticky vygenerované ¹ablony. Pro získání prvního atributu (jména) slou¾í metoda \verb|name|.

Vytvoøení seøazeného faktu je velice jednoduché. Konstruktor v tomto pøípadì oèekává dva parametry. Prvním je jméno skupiny (objekt tøídy \verb|String| nebo \verb|Symbol|) a druhım pole v¹ech atributù neseøazeného faktu. Pøíklady mo¾nıch zápisù tvorby seøazeného faktu jsou uvedeny na Obrázku~\ref{rbclips_example_fact_ordered}.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
Fact.new 'Jarcec', [20, "muz"]
Fact.new 'pohlavi', %w(muz zena)
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ukázka vytvoøení seøazeného faktu.}
  \label{rbclips_example_fact_ordered}
\end{figure}

\subsubsection{Neseøazenı fakt}
Práce s neseøazenımi fakty je v prostøedí rbClips o dost pohodlnìj¹í ne¾ v pøípadì seøazenıch faktù. Existují dvì základní metody podobné tìm, které jsou k dispozici v pøípadì seøazeného faktu. První z nich je metoda \verb|slot(String or Symbol)| vracející hodnotu ulo¾enou v daném slotu a metoda \verb|template| vracející ¹ablonu, podle které byl fakt vytvoøen (tedy objekt tøídy \verb|Template|).

Navíc ov¹em rbClips plnì vyu¾ívá dynamiènosti a otevøenosti Ruby a pro jednotlivé sloty vytváøí pøístupové metody shodného jména jako sloty samotné. \u{C}ím¾ velice napodobuje chování ActiveRecords, které vytváøí pøístupové metody instance podle názvù sloupcù pøíslu¹nıch relaèních tabulek. Jednotlivé instance neseøazenıch faktù mají rùzné metody, vygenerované podle ¹ablony, ze které byly vytvoøeny. Z tohoto dùvodu je dobré dávat pozor a nevytváøet ¹ablony se jmény slotù, které jsou stejné jako ji¾ existující metody. Pøíkladem nevhodného jména slotu je napøíklad \verb|save|. Pokud bude ¹ablona obsahovat takto pojmenovanı slot, tak pùvodní metoda \verb|save|, bude pøekryta metodou pro pøístup k atributùm faktu a nebude vùbec mo¾né instanci ulo¾it do prostøedí CLIPS.

V pøípadì tvorby neseøazeného faktu oèekává konstruktor dvojici parametrù. Prvním z nich musí bıt ulo¾ená instance ¹ablony (tøída \verb|Template|), druhım je asociativní pole, kde klíèe jsou jména slotù ¹ablony a jejich hodnoty jsou ulo¾eny do tìchto slotù pøi vytváøení faktu. Ukázka je k dispozici na Obrázku~\ref{rbclips_example_fact_nonordered}.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
# pro neserazeny fakt je zapotrebi sablony
animal = Template.new :name => 'animal', 
  :slots => %w(name age race)
animal.save

# tvorba dvou neserazenych faktu
Fact.new animal, :name => "Azor"
Fact.new animal, :name => "Zorka", :age => 2
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ukázka vytvoøení neseøazeného faktu.}
  \label{rbclips_example_fact_nonordered}
\end{figure}

\subsection{Tøída Rule}
Poslední z hlavních tøíd knihovny rbClips zapouzdøuje práci s pravidly. Ty v CLIPS mají nezastupitelnou roli, proto¾e je v nich ulo¾ena informace, co se má a za jakıch podmínek provést. Rozhodovací jádro CLIPS jen vybírá podle rùznıch, mnohdy u¾ivatelsky nastavitelnıch kriterií, které pravidla se mají a v jakém poøadí provést. V rámci CLIPS jednou vytvoøená pravidla ji¾ nelze dále upravovat, proto i rbClips vytváøí tyto objekty needitovatelné. Vıjimkou z needitovatelnosti je samozøejmì tvorba pravidla v rámci konstruktoru tøídy.

Tvorba nového pravidla je mírnì slo¾itìj¹í, a proto se jí budu detailnì v následujících odstavcích vìnovat. Nové pravidlo se vytváøí tvorbou nového objektu tøídy \verb|Rule| tak, jak je v Ruby svìte zvykem voláním metody \verb|new|. Tato metoda vy¾aduje pøedání bloku pøijímací právì jeden argument, pomocí kterého bude následnì celé pravidlo sestaveno. Pøedanı argument je instance tøídy \verb|RuleCreator| umo¾nující pomocí svıch metod nadefinovat jak levou, tak i pravou stranu pravidla.

Jak bylo uvedeno v kapitole~\ref{clips_knowledge_base} pravidla mohou obsahovat promìnné. Ty jsou pøi aktivaci pravidla zamìnìny za skuteèné hodnoty a v¾dy platí, ¾e v¹echny promìnné stejného jména jsou nahrazeny právì jednou hodnotou. V rbClips roli promìnnıch pøebírají symboly. Existují ov¹em dva speciální symboly, které jsou vıjimkou z uvedeného pravidla, a které se pou¾ívají v podstatì pouze u seøazenıch faktù. Prvním je symbol \verb|:one|, slou¾ící pro nahrazení libovolné hodnoty atributu, ov¹em více vıskytù mù¾e bıt nahrazeno více mo¾nımi hodnotami. Slou¾í k pøeskakování nezajímavıch hodnot neseøazenıch faktù, které programátora v rámci vytváøeného pravidla nezajímají. Druhım speciálním symbolem je \verb|:any|. Chová se velice podobnì jako symbol \verb|:one|, akorát za nìj mù¾e bıt v seøazeném faktu substituována více ne¾ jedna hodnota.

Nejdùle¾itìj¹í metodou pro editaci levé strany pravidla je metoda \verb|pattern|. Slou¾í pro vyhledávání urèitıch vzorù (takzvanı pattern matching). Má velice bohaté mo¾nosti argumentù, se kterımi mù¾e bıt volána a vrací v¾dy objekt tøídy \verb|FactAddress|. Vrácenı objekt mù¾e bıt následnì pou¾it v metodách upravujících pravou stranu pravidla. První mo¾nost volání je urèena pro vyhledávání seøazenıch faktù a spoèívá v pøedaní jednoho objektu tøídy \verb|String| nebo \verb|Symbol| a následnì jednoho pole. První argument je pou¾it jako jméno skupiny pøíbuznıch faktù a pole je interpretováno jako vyhledávací vzor na této mno¾inì. Symboly v tomto poli jsou pou¾ity jako zástupné promìnné, které mají v rámci aplikování pravidla v¾dy stejnou hodnotu tak, jak bylo popsáno v pøedchozích odstavcích. Druhım mo¾nım voláním je pøedat jako první argument objekt tøídy \verb|Template| a následnì jednoho asociativního pole. Velice podobnì jako v pøedchozím pøípadì potom první argument slou¾í pro urèení, na jaké podmno¾inì faktù se bude vyhledávat (ve v¹ech faktech, vytvoøenıch podle pøedané ¹ablony). Asociativní pole obsahuje jako klíèe sloty ¹ablony a jako hodnoty vyhledávané vzory. Opìt lze pou¾ít symboly jako zástupné hodnoty stejné pøes volání v¹ech metod vytváøeného pravidla. Poslední mo¾ností je pøedat metodì \verb|pattern| jeden objekt tøídy \verb|String|, kterı bude beze zmìny ulo¾en do CLIPS. Slou¾í pro vlastní specifikování vyhledávaného vzoru pro pøípady, kdy rbClips nedostateènì zapouzdøuje mo¾nosti CLIPS.

Velice podobnou metodou je metoda \verb|retract|. Jako jedna z mála upravuje jak levou, tak zárovì\v{n} i pravou stranu pravidla. Na levé stranì pravidla urèuje vyhledávací vzor a proto akceptuje stejné mo¾nosti parametrù jako metoda \verb|pattern|. Navíc s ní sdílí i stejnou návratovou hodnotu, objekt tøídy \verb|FactAddress|. Na rozdíl od ní ov¹em, po aktivaci pravidla nalezenı fakt sma¾e.

Metody \verb|pattern| a \verb|retract| afektují levou stranu pravidla, tedy urèují za jakıch pod\-mí\-nek se pravidlo aplikuje. Pokud je jich v definici pravidla uvedeno více, tak je mezi nì dána logická spojka ''a souèasnì`` (and). Tedy v¹echny vyhledávané vzory musí bıt nalezeny, aby dané pravidlo mohlo bıt aplikováno. Pro mo¾nost jemnìj¹ího definování levé strany existují tøí metody s obdobnım pou¾itím - \verb|and|, \verb|or| a \verb|not|. Tyto metody vy¾adují pøedání bloku s jedním parametrem, do kterého bude pøedán opìt objekt tøídy \verb|RuleCreator|. Vyhledávané vzory definované uvnitø pøedaného bloku budou hledanı s logickou spojkou podle pøíslu¹ného názvu metody. Pro je¹tì jemnìj¹í nastavování podmínek rbClips umo¾\v{n}uje vzájemné zanoøovaní tìchto blokù do sebe. Dùle¾itou vıjimkou z prezentovaného chování je absence metody \verb|retract|, která v bloku \verb|not| a ve v¹ech jemu vnoøenıch ji¾ není k dispozici. Chybí zde z logického dùvodu. Metoda \verb|retract| slou¾í po aktivaci pravidla ke smazání faktu z pamìti. Ov¹em blok \verb|not| zaruèuje, ¾e danı fakt neexistuje a logicky tedy není ani co vymazat. Velice obdobnì je uvnitø \verb|not| bloku zmìnìno chování metody \verb|pattern|, která místo objektu \verb|FactAddress| vrací \verb|nil|.

Velice u¾iteènım roz¹íøením mo¾ností CLIPS v knihovnì rbClips je mo¾nost v rámci pravé strany volat metodu libovolného objektu Ruby. Registrovaní objektu a jeho metody se provádí metodou \verb|rcall|, která má minimálnì dva povinné argumenty. Prvním je objekt, na kterém má byt zavolána metoda specifikovaná v druhém parametru. Dal¹í parametry jsou nepovinné a slou¾í k pøedání parametrù volané metody. Samozøejmostí je mo¾nost zadat na tomto místì symbol, kterı v koneèném voláním metody bude nahrazen pøíslu¹nou aktivaèní hodnotou, za kterou byl symbol nahrazen. Tento zpùsob reakce na aktivaci pravidla je jeden z nejdùle¾itìj¹ích pøínosù knihovny rbClips do vıslednıch expertních systému na ni zalo¾enıch. Mo¾nost volat v rámci pravidla metodu na libovolném objektu Ruby umo¾òuje do vısledného expertního systému zakomponovat libovolnou ji¾ existující knihovnu Ruby. Navíc pøiná¹í do procesu vykonávání pravidla dynamiku typickou pro jazyk Ruby. V rámci volané metody lze toti¾ napøíklad získávat data z relaèních databází a na jejich základì se rozhodovat o dal¹ím postupu.

Poslední zatím nezmínìnou metodou objektu \verb|RuleCreator| je metoda \verb|rhs|. Akceptuje právì jeden argument tøídy \verb|String|, kterı bez jakıchkoliv kontrol vlo¾í do pravé strany vytváøeného pravidla. Slou¾í jako záchrana v pøípadì, ¾e po¾adovaná funkcionalita není mou knihovnou zapouzdøena. Komplexnìj¹í pøíklad tvorby pravidla je na Obrázku~\ref{rbclips_example_rule}.

Po vytvoøení pravidla je potøeba ho je¹tì ulo¾it do CLIPS pomocí metody \verb|save|. Pravidla se zaènou aktivovat a¾ po spu¹tìní rozhodovacího algoritmu, kterı se v rbClips spou¹tí pomocí metody \verb|run| modulu \verb|Base|.

\begin{figure}[t]
\hspace{1cm}
\begin{minipage}{100\%}
  \begin{verbatim}
savci = Rule.new "savci" do |r|   # pravidlo "savci"
  r.pattern 'animal', :name       # musi existovat "animal"
  r.pattern 'warm-blooded', :name # a zaroven teplokrevne
  r.not do |n|                    # nesmi ovsem klast
    n.pattern 'lays-eggs', :name  # vejce
  end
  r.assert 'mammal', :name        # vytvor noveho savce
end
\end{verbatim}
\end{minipage}
  \vspace{-0.2cm}
  \caption{Ukázka vytvoøení pravidla.}
  \label{rbclips_example_rule}
\end{figure}

\section{Implementaèní zajímavosti}
V následujících odstavcích bych se rád vìnoval implementaèním zajímavostem, na které jsem v rámci této práce narazil. Nejprve bych se ov¹em rád vìnoval vıbìru zpùsobu tvorby samotného binárního roz¹íøení. Nejjednodu¹¹í pøístup automatického vytvoøení celého rozhraní by zachoval dostupné funkce CLIPS i s jejich parametry. U¾ivatel knihovny by byl nucen uèit se navíc je¹tì syntaxi u¾ivatelského rozhraní CLIPS, co¾ bylo po¾adavky vylouèeno. V úvodních verzích návrhu jsem se proto pøiklonil spí¹e ke kombinovanému pøístupu. Nad automaticky vygenerovanım rozhraním jsem napsal vy¹¹í zapouzdøovací logiku, která celé procedurální chování zapouzdøila do objektù. S tímto pøístupem dokonce vzniklo nìkolik funkèních prototypù knihovny na prezentaci, ¾e to takto mù¾e fungovat (tzv. ''proof of concept``). Prototypy sice fungovaly, ov¹em kvùli neustálému pøevádìní v¹ech datovıch typù z Ruby objektù do jazyka C a zpìt pøi ka¾dé operaci trpìly slab¹ím vıkonem. Napøíklad i jinak velice rychlá práce s ukazateli jazyka C byla zpomalena neustálımi konverzemi do objektù, které byly pøedány do vy¹¹ích vrstev ke zpracování, a následnému pøevedení zpìt na ukazatele, aby se na jejich základì provedla v CLIPS urèitá operace (napøíklad nalezení urèitého faktu).

Proto jsem se nakonec rozhodl celé rozhraní napsat v jazyce C a dodávat jako èistì binární roz¹íøení. Po dùkladném pøeètení dokumentace k Ruby jsem navíc zjistil, ¾e umo¾òuje do objektù ulo¾it i ukazatel na libovolnou strukturu, o kterou se navíc stará sám interpret. Garbage collector pøed uvolnìním objektu obsahujícího ukazatel zavolá nejprve registrovanou uvol\v{n}ovací funkci na tento ulo¾enı ukazatel a a¾ následnì objekt odstraní. Nejèastìji je registrovaná funkce \verb|free()|, ale v pøípadì potøeby lze pro slo¾itìj¹í struktury zaregistrovat zcela libovolnou funkci (pøijímací právì jeden parametr typu \verb|void *|). Ta mù¾e strukturu postupnì uvolnit tak, aby nedo¹lo k ¾ádnım únikùm pamìti.

Tímto zpùsobem do objektù ukládám vlastnì vytvoøené struktury obsahující minimálnì jednu promìnou. Tou je ukazatel \verb|void *| ukazující na vnitøní struktury CLIPS. Napøíklad Ruby objekt reprezentující fakt má ve vnoøeném ukazateli ulo¾en odkaz na strukturu, která mimo jiné obsahuje odkaz na jeho strukturu v CLIPS. Tím pádem mám k dispozici rychlé spojení mezi Ruby objektem a jeho CLIPS reprezentací. Nemusím poka¾dé popisovanou entitu vyhledávat a v¹echny operace jsou podstatnì rychlej¹í.

\section{Pøeklad}
Zdrojové k\'{o}dy knihovny rbClips jsou k dispozici na pøilo¾eném CD. Na tém¾e CD je k dispozici i celı Git repositáø (Git je nástroj pro udr¾ování verzí souborù podobnì jako CVS nebo Subversion). \u{C}tenáø má tedy pøístup k celé historii projektu, ne jen k jeho odevzdané verzi. Vıvoj knihovny dnem odevzdání bakaláøské práce navíc nekonèí a nejaktuálnìj¹í verzi lze stáhnout z veøejného git repositáøe serveru Github \footnote{Zdrojové k\'{o}dy projektu lze ze serveru Github stáhnout pomocí pøíkazu \\ \textbf{git clone git://github.com/jarcec/rbclips.git}}.

Knihovna má dvì hlavní závislosti - CLIPS a Ruby. CLIPS je mo¾né stáhnout z oficiálních stránek projektu a to zvlá¹\v{t} balíèek se zdrojovımi k\'{o}dy a s rùznımi \verb|makefile| soubory. \verb|Makefile| soubor pro pøeklad knihovny bohu¾el obsahuje chybu. Chybí v nìm flag \verb|-fPIC|, bez kterého se nedá dynamická knihovna vytvoøit. Proto jsem se rozhodl umístit zdrojové k\'{o}dy CLIPS, oproti kterım je má bakaláøská práce vytvoøena a otestována, pøímo do svého repositáøe. Odpadá tedy nutnost ruèního stahování CLIPS.

Druhá hlavní závislost\,--\,interpret Ruby\,--\,ji¾ v dodaném repositáøi z dùvodu pøítomnosti ve vìt¹inì distribucí a velice aktivnímu vıvoji pøítomna není. Pro pøeklad je potøeba mít v systému nainstalován nejen samotnı interpret, ale i jeho pøípadné vıvojové balíèky. Po¾adovaná verze je 1.9.x, dnes ji¾ pouze udr¾ovaná vìtev 1.8 není rbClips podporována a knihovna nepùjde s touto verzí pøelo¾it. Pro pøípad absence v nìjaké neobvyklé distribuci je archív s podporovanou verzí Ruby pøítomen také na pøilo¾eném CD.

Z obvyklıch závislostí je potøeba mít prostøedí pro pøeklad, tedy hlavnì pøekladaè \verb|gcc|. Z rodiny nástrojù \verb|autotools| je potøeba pouze balíèek s programem \verb|make|. Ostatní nejsou potøeba, proto¾e \verb|Makefile| pro pøeklad binárního roz¹íøení vytvoøí Ruby skript, kterı je pro tyto úèely dodán. V koøenové slo¾ce projektu je ji¾ vytvoøen hlavní soubor \verb|Makefile|, kterı obsahuje v¹echny èásti pøekladu pohromadì. Pro samotnı pøeklad tedy staèí spustit program \verb|make| v koøenové slo¾ce knihovny. Jako první se pøelo¾í zahrnutá verze CLIPS a a¾ následní vlastní knihovna rbClips. V poslední fázi pøekladu se spustí automatické testy pro ovìøení správnosti a funkènosti pøekladu.

\section{Praktickı pøíklad}
Jako poslední podkapitolu o knihovnì rbClips bych rád uvedl tro¹ku slo¾itìj¹í pøíklad spolu s jeho slovním popisem. Ukázka je zobrazena na Obrázku~\ref{rbclips_complex_example1} a ukazuje vyhledávaní savcù na mno¾inì rùznıch zvíøat a jejich vlastností.

Nejprve vytvoøím v¹echny fakta o zvíøatech a jejich vlastnostech za pou¾ití seøazeného faktu (poznámka \verb|#1|). Za pov¹imnutí stojí forma zápisu, kdy nepou¾ívám jeden dlouhı fakt se seznamem v¹ech vlastností daného zvíøete. Místo toho mám v¾dy vlastnost a jako její atribut jméno zvíøete ke kterému nále¾í. Tento zpùsob mi jednodu¹¹í následnı zápis pravidel.

První pravidlo (poznámka \verb|#2|) vyhledává savce podle dvou vlastností. Za prvé musí byt teplokrevní a za druhé nesmìjí klást vajíèka. Pravidlo krásnì prezentuje pou¾ití symbolu jako zástupné promìnné pro jméno zvíøete a pou¾ití bloku \verb|not|. Druhé pravidlo (poznámka \verb|#3|) vyjadøuje lidsky zapsanou vìtu: ''Je-li rodiè savcem, poté i jeho potomek je savcem``. Opìt lze krásnì vidìt funkci symbolù jako¾to zástupnıch znakù a to jak pro jméno rodièe, tak i pro jméno jeho potomka. Ka¾dé pravidlo bude spu¹tìno pro v¹echny platné kombinace, které budou v mno¾inì vstupních faktù nalezeny. Navíc spu¹tìní rozhodovacího algoritmu (poznámka \verb|#4|) není omezeno ¾ádnım maximálním poètem aplikovanıch pravidel, tak¾e rozhodovací algoritmus svou èinnost ukonèí a¾ ji¾ nebude mít ¾ádná pravidla k aktivaci. 

Po dokonèení ukázkového programu pøibudou do mno¾iny faktù celkem 4 nová fakta pro savce. Na základì prvního pravidla se bude jednat o identifikování savce koèky a psa a na základì druhého pravidla je¹tì fakta pro jejich potomky, tedy kotì a ¹tìnì.

\begin{figure}[tbh]
  \begin{verbatim}
#1
Fact.new('animal', %w(dog)).save
Fact.new('animal', %w(cat)).save
Fact.new('animal', %w(duck)).save
Fact.new('animal', %w(turtle)).save
Fact.new('warm-blooded', %w(dog)).save
Fact.new('warm-blooded', %w(cat)).save
Fact.new('warm-blooded', %w(duck)).save
Fact.new('lays-eggs', %w(duck)).save
Fact.new('lays-eggs', %w(turtle)).save
Fact.new('child-of', %w(dog puppy)).save
Fact.new('child-of', %w(cat kitten)).save
Fact.new('child-of', %w(tutrle hatchling)).save

#2
mammal1 = Rule.new "mammal" do |r|
  r.pattern 'animal', :name
  r.pattern 'warm-blooded', :name
  r.not do |n|
    n.pattern 'lays-eggs', :name
  end
  r.assert 'mammal', :name
end
mammal1.save

#3
mammal2 = Rule.new "childs" do |r|
  r.pattern 'mammal', :name
  r.pattern 'child-of', :name, :young
  r.assert 'mammal', :young
end
mammal2.save

#4
Base.run
\end{verbatim}
  \vspace{-0.7cm}
  \caption{Pøíklad pou¾ítí knihovny rbClips}
  \label{rbclips_complex_example1}
\end{figure}

%=========================================================================
\chapter{Závìr}
%=========================================================================
Knihovnu rbClips jsem úspì¹nì naprogramoval podle v¹ech po¾adavkù a odzkou¹el na základì testù, které jsou souèástí knihovny. V souèasné dobì probíhá její dal¹í testovaní pro odhalení rùznıch chyb, kterıch jsem si pøi vlastním testování nev¹iml. Dal¹ím krokem bude pou¾ít knihovnu k tvorbì expertního systému v Ruby pro automatickou klasifikaci vzorkù malware, tak jak jsem zmínil v úvodu. 

Mezi vıhody knihovny rbClips a pøednosti jejího pou¾ití oproti pøímému pou¾ití CLIPS mohu uvést:

\textbf{Zapouzdøení procedurálního chování.} Manuální pøístup k tvorbì zpøístup\v{n}ovacího binárního roz¹íøení mi umo¾nil zapouzdøit jednotlivé skupiny funkcí do tøíd. Napøíklad v¹echny funkce pracující s fakty jsou, a\v{t} u¾ pøímo èi nepøímo, volány pomocí metod tøídy Fact. Samotná tøída navíc celé rozhraní pøizpùsobuje objektovému návrhu a nepsanım konvencím jazyka Ruby. Programátor pou¾ívající rbClips si vùbec nemusí bıt vìdom, ¾e na ni¾¹í úrovni se pou¾ívá pouze procedurální knihovna napsaná v jazyce C.

\textbf{Zapouzdøení syntaxe CLIPS.} Zapouzdøení celého rozhraní knihovny rbClips do objektù umo¾nilo schovat u¾ivatelské rozhraní CLIPS. Programátor se tak nemusí uèit dal¹í jazyk, navíc od Ruby velice odli¹nı, kterım by ovládal prostøedí CLIPS. Nìkteré ménì vyu¾ívané konstrukce CLIPS nejsou bohu¾el v rbClips pøímo podporovány, a proto jsem pøidal mo¾nost vkládat a vykonávat validní úryvky CLIPS k\'{o}du pøímo. 

\textbf{Zpìtné volání Ruby metod.} Knihovna obsahuje mo¾nost jako akci pro pravidla (konsekvent) nastavit metodu libovolného objektu Ruby. Ta se po aktivaci pravidla zavolá. Do takto volané metody lze pøedat libovolné parametry a to nejen ty známé v dobì tvorby pravidla, ale tøeba i ty které vedly k aktivaci pravidla.

\textbf{Vyu¾itı v¹ech dostupnıch Ruby knihoven.} Ve vısledném expertním systému jeho¾ základem bude knihovna rbClips, lze vyu¾ívat naprosto libovolnou, ji¾ existující knihovnu Ruby. Díky mo¾nosti volání libovolné metody v rámci aktivace pravidel lze napøíklad v dobì vyhodnocení pravidla pou¹tìt dotazy v relaèních databázích nebo spou¹tet externí utility.

\textbf{Pøímı pøístup ke CLIPS.} Pro pøípad, ¾e u¾ivatelem po¾adovaná funkcionalita CLIPS není knihovnou rbClips zpøístupnìna, je mo¾né ovládat celı expertní systém i za pou¾ití u¾ivatelského rozhraní CLIPS. Tato vıhoda se mù¾e obzvlá¹tì hodit v pøípadì pøechodu ji¾ existujícího systému na knihovnu rbClips, proto¾e existující zdrojové kódy lze pou¾ít pøímo. Pøechod lze uskuteènit po èástech a není potøeba hned v¹echny zdrojové kódy pøepsat do Ruby.

Knihovna by mohla slou¾it jako základ dopl\v{n}ku ke stávajícímu antivirovému jádru. To klasifikuje viry na základì vyhledávání rùznıch vzorù v prohledávanıch souborech. K tomu by ¹lo vytvoøit druhé jádro kvalifikující malware na základì jeho chování (tedy behaviour detekce), jejím¾ základem by byla právì knihovna rbClips. Operaèní systém by hlásil akce jednotlivıch programù. Napøíklad alokace velkého bloku souvislé pamìti, roz¹ifrování dat do této pamìti a její následné spu¹tìní. rbClips knihovna by poté rozhodovala zda-li je chovaní programù správné a pøípustné. Pøípadnì by oznaèila danı program za malware a oznámila v¹e u¾ivateli. Samozøejmì by vısledné nové jádro antiviru mohlo vyu¾ívat ve¹keré mo¾nosti, které nabízí jak CLIPS, tak i Ruby. Napøíklad nechat zkontrolovat stávajícím jádrem u¾ roz¹ifrovanı k\'{o}d malwaru, kterı pøedtím nemusel bıt detekován.
